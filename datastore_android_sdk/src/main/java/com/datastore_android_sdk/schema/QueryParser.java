/**  * QueryParser.java * * Copyright (c) 2008-2014 Joy Aether Limited. All rights reserved. * * Unauthorized copying of this file, via any medium is strictly prohibited. *  * This unpublished material is proprietary to Joy Aether Limited. * All rights reserved. The methods and * techniques described herein are considered trade secrets * and/or confidential. Reproduction or distribution, in whole * or in part, is forbidden except by express written permission * of Joy Aether Limited. */package com.datastore_android_sdk.schema;import java.lang.reflect.Method;import java.lang.reflect.Type;import java.sql.SQLException;import java.sql.Timestamp;import java.util.ArrayList;import java.util.Arrays;import java.util.Date;import java.util.HashMap;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Set;import com.google.gson.reflect.TypeToken;import com.j256.ormlite.dao.Dao;import com.j256.ormlite.dao.DaoManager;import com.j256.ormlite.stmt.QueryBuilder;import com.j256.ormlite.stmt.StatementBuilder;import com.j256.ormlite.stmt.Where;import com.j256.ormlite.support.ConnectionSource;/** * A utility class that parses a {@link Query} into a {@link StatementBuilder} */public final class QueryParser {		/** Error messages */	private final String ERROR_SQL_SYNTAX	= "You have an error in your SQL syntax";	private final String ERROR_NULL_POINTER		= "At least one of the required parameter(s) is missing";		private final String KEY_STATEMENT			= "__statement__";	private final String KEY_WHERE_CLAUSE		= "__where__";		private ConnectionSource connectionSource;	private ModelAttributes attributes;		/** The {@link Where} object as a result of parsing a query. */	private Where<?, ?> where;		/** A Map of value deserializers */	private Map<TypeToken<?>, QueryDeserializer<?>> deserializers =		new HashMap<TypeToken<?>, QueryDeserializer<?>>();		/** A List of deserializer factories */	private List<QueryDeserializerFactory> factories;		/**	 * Creates a query parser instance that can be used to parse a query	 * with various configuration settings	 */	public QueryParser() {		factories = new ArrayList<QueryDeserializerFactory>();		factories.add(QueryDeserializers.STRING_FACTORY);		factories.add(QueryDeserializers.BIG_DECIMAL_FACTORY);		factories.add(QueryDeserializers.BIG_INTEGER_FACTORY);		factories.add(QueryDeserializers.BOOLEAN_FACTORY);		factories.add(QueryDeserializers.BYTE_FACTORY);		factories.add(QueryDeserializers.DOULBE_FACTORY);		factories.add(QueryDeserializers.FLOAT_FACTORY);		factories.add(QueryDeserializers.INET_ADDRESS_FACTORY);		factories.add(QueryDeserializers.INTEGER_FACTORY);		factories.add(QueryDeserializers.LONG_FACTORY);		factories.add(QueryDeserializers.NUMBER_FACTORY);		factories.add(QueryDeserializers.SHORT_FACTORY);		factories.add(QueryDeserializers.URI_FACTORY);		factories.add(QueryDeserializers.URL_FACTORY);		factories.add(QueryDeserializers.UUID_FACTORY);		factories.add(QueryDeserializers.ENUM_FACTORY);		factories.add(QueryDeserializers.newFactory(Date.class, QueryDeserializers.DATE));		factories.add(QueryDeserializers.newFactory(Timestamp.class, QueryDeserializers.DATE));		factories.add(QueryDeserializers.newFactory(java.sql.Date.class, QueryDeserializers.DATE));	}		/**	 * Parses the given Query object to an ORMLite statement	 * 	 * @param query	 *            the Query object to be parsed	 * @param statementBuilder	 *            the object to assist building SQL statements	 * @param connection	 *            the connection to the underlying database	 * @param type	 *            the object type to perform the query on	 * @return a SQL query statement object	 * @throws SQLException	 *             thrown if there was an error parsing the Query object	 */	public <T> QueryBuilder<T, ?> parse(			Query query,			QueryBuilder<T, ?> statementBuilder,			ConnectionSource connection,			Class<T> type) throws SQLException {		return parse(query, false, statementBuilder, connection, type);	}	/**	 * Parses the given Query object to an ORMLite statement	 * 	 * @param query	 *          the Query object to be parsed	 * @param isCountQuery	 *          {@code true} if the query part of the request is to be parsed as a	 *          count query. If {@code true}, the $orderby, $top and $skip query	 *          options will be omitted	 * @param statementBuilder	 *          the object to assist building SQL statements	 * @param connection	 *          the connection to the underlying database	 * @param type	 *          the object type to perform the query on	 * @return a SQL query statement object	 * @throws SQLException	 *           thrown if there was an error parsing the Query object	 */	public <T> QueryBuilder<T, ?> parse(			Query query,			boolean isCountQuery,			QueryBuilder<T, ?> statementBuilder,			ConnectionSource connection,			Class<T> type) throws SQLException {				// Quick return if the QueryBuilder object or query parameters are null		if (connection == null || query == null) {			throw new SQLException(ERROR_NULL_POINTER);		}		connectionSource = connection;		attributes = Schema.getAttributes(type);		if (!isCountQuery) {			parseOrderings(query.getOrderings(), statementBuilder);			parseRange(query.getRange(), statementBuilder);		}		parseGroupBy(query.getGroupBy(), statementBuilder);		parseDistinct(query.isResultDistinct(), statementBuilder);		where = parseArguments(query.getArguments(), type, statementBuilder);		parseSelects(query.getSelectFields(), statementBuilder);		return statementBuilder;	}		/**	 * Parses the given Query object to an ORMLite statement	 * @param query the Query object to be parsed	 * @param statementBuilder the object to assist building SQL statements	 * @param type the type of the queried resource	 * @return a SQL query statement object	 * @throws SQLException thrown if there was an error parsing the Query object	 */	public <T> StatementBuilder<T, ?> parse(			Query query, 			StatementBuilder<T, ?> statementBuilder, 			Class<T> type) throws SQLException {		// Quick return if the QueryBuilder object or query parameters are null		if (statementBuilder == null || query == null) {			throw new SQLException(ERROR_NULL_POINTER);		}		attributes = Schema.getAttributes(type);		where = parseArguments(query.getArguments(), type, statementBuilder);		return statementBuilder;	}		/**	 * Returns the {@link Where} object as the result of parsing a given query. 	 * 	 * @return the {@link Where} object from the last call to {@link #parse(Query, QueryBuilder, ConnectionSource, Class)}	 */	public Where<?, ?> getWhereStatement() {		return where;	}	/**	 * Parses the given orderings in the query	 * @param orderings a hash map of ordering for the given columns	 * @param statementBuilder the object to assist building SQL statements	 * @param fieldNamingScheme the scheme used to translate the name of a column in a query	 * to the database column name	 */	private <T> void parseOrderings(			Map<String, String> orderings, 			QueryBuilder<T, ?> statementBuilder) {				// quick return if the QueryBuilder object is null		if (statementBuilder == null)			return;				Set<String> columns = orderings.keySet();		for (String name : columns) {			String sortDirection = orderings.get(name);			boolean ascending = sortDirection.equals(Query.Ordering.ASCENDING.toString());			statementBuilder.orderBy(attributes.getColumnName(name), ascending);		}	}		/**	 * Specifies the range of records to be returned in the results	 * @param range a hash map of lower and upper range to of the results	 * @param statementBuilder the object to assist building SQL statements	 * @throws SQLException thrown if the database does not support offset	 */	private <T> void parseRange(			Map<String, Long> range, 			QueryBuilder<T, ?> statementBuilder) throws SQLException {				// quick return if the QueryBuilder object is null		if (statementBuilder == null || range == null)			return;				Long offset = range.get(Query.LOW_RANGE);		if (offset != null && offset >= 0) {			statementBuilder.offset(offset);		}				Long limit = range.get(Query.HIGH_RANGE);		if (limit != null && limit >= 0) {			statementBuilder.limit(limit);		} else if (offset != null && offset >= 0) {			statementBuilder.limit(Long.MAX_VALUE);		}	}		/**	 * Add columns to be returned by the query.	 * 	 * @param selectFields the columns to be returned by the query	 * @param statementBuilder the object to assist build SQL statements	 * @throws SQLException thrown if there was error parsing the arguments	 */	private <T> void parseSelects(			Map<String, ?> selectFields, 			QueryBuilder<T, ?> statementBuilder) throws SQLException {				// Quick return if the QueryBuilder object or query parameters are null		if (statementBuilder == null || selectFields == null) {			return;		}				// FIXME: honor selects in joined statements		if (!selectFields.isEmpty()) {			List<String> columns = new ArrayList<String>();			for (String key : selectFields.keySet()) {				String columnName = attributes.getColumnName(key);				if (!columnName.isEmpty() && !columns.contains(columnName)) {					columns.add(columnName);				}			}						if (!columns.isEmpty()) {								statementBuilder.selectColumns(columns);			}		}	}		/**	 * Group the results by a column name	 * @param columnName the name of column to be grouped by	 * @param statementBuilder the object to assist building SQL statements	 * @throws SQLException thrown if there was an error parsing the arguments	 */	private <T> void parseGroupBy(			String columnName, 			QueryBuilder<T, ?> statementBuilder) throws SQLException {		// Quick return if the QueryBuilder object or query parameters are null		if (statementBuilder == null || columnName == null) {			return;		}		statementBuilder.groupBy(columnName);	}		/**	 * Adds a "DISTINCT" clause to the query	 * @param resultShouldBeDistinct {@code true} to indicate results should be distinct, {@code false} otherwise	 * @param statementBuilder the object to assist building SQL statements	 * @throws SQLException thrown if there was an error parsing the "distinct" argument	 */	private <T> void parseDistinct(			boolean resultShouldBeDistinct,			QueryBuilder<T, ?> statementBuilder) throws SQLException {				// Quick return if the QueryBuilder object or query parameters are null		if (statementBuilder == null) {			return;		}				if (resultShouldBeDistinct) {			statementBuilder.distinct();		}	}		/**	 * Parses the given query arguments	 * @param args a hash map of query arguments	 * @param schemaType the type of object to perform the query on	 * @param statementBuilder the object to assist building SQL statements	 * @throws SQLException thrown if there was an error parsing the arguments	 */	@SuppressWarnings("unchecked")	public <T> Where<T, ?> parseArguments(			Map<String, Map<String, ?>> args,			Class<T> schemaType,			StatementBuilder<T, ?> statementBuilder) throws SQLException {		// Quick return if the StatementBuilder object or query parameters are		// null		if (statementBuilder == null || args == null) {			return null;		}				try {			Map<String, Object> queries = new HashMap<String, Object>();			queries.put(KEY_STATEMENT, statementBuilder);						Set<String> attributes = args.keySet();			for (String attributeName : attributes) {				// Parse query options on a given column				Map<String, ?> operation = (Map<String, ?>) args.get(attributeName);				if (operation != null) {					Set<String> operators = operation.keySet();					for (String operator : operators) {						// Obtain the query value						Object value = operation.get(operator);												// Parses the argument into a {@code StatementBuilder} object						parseQueryArgument(								operator,								queries,								schemaType,								Arrays.asList(attributeName.split("\\s*" + Query.FIELD_SEPARATOR + "\\s*")),								value);					}				}			}						Where<T, ?> where = (Where<T, ?>) queries.get(KEY_WHERE_CLAUSE);			return where;		} catch (Exception ex) {			// The SQL statement could not be compiled			throw new SQLException(ERROR_SQL_SYNTAX);		}	}		/**	 * This method creates and joins where statements for standard operator (eq, ne, gt, gte, lt, lte)	 * 	 * @param operator	 *            Method object of where operation in Where class (eq, ne, gt, gte, lt, lte).	 *            This argument will not be modified.	 * @param queries	 *            Tree-like structure of query parameters. There are 3 main entries at each level (i.e. {@link #KEY_STATEMENT} (KS) 	 *            that stores the {@link StatementBuilder}, {@link #KEY_WHERE_CLAUSE} (KWC) that stores the {@link Where} clause	 *            associated with the {@link StatementBuilder} at the level and {@link Map<K, V>} that stores the next level of 	 *            {@link StatementBuilder} and {@link Where} clause for the given column.	 *             	 *            This function will modify the collection (add new node) as the function runs recursively.	 *            e.g. ?a/b/c=1&a/d/e=2 will translate to 	 *            { KS: qbo1,	 *              'a': { KS: qbo2,	 *                'b': { KS: qbo3,	 *                  'c': { KS: qbo4, KWC: wo4 }	 *                },	 *                'd': { KS: qbo5,	 *                  'e': { KS: qbo6, KWC: wo6 }	 *                }	 *              }	 *            }	 * @param schemaType	 *            Schema class type (usually classes inside schema package).	 *            This argument will not be modified.	 * @param attributeNames	 *            List of query strings separated by slash.	 *            e.g. ?a/b/c=1 should be ["a", "b", "c"]	 *            This argument will not be modified.	 * @param value	 *            value of query string, object type depend on the value.	 *            e.g. ?a/b/c=1 should be 1, type should be long.	 *            This argument will not be modified	 * @throws SQLException	 *             Thrown if there was an error parsing the Query object	 */	@SuppressWarnings("unchecked")	protected <T> void parseQueryArgument(			String operator,			Map<String, Object> queries, 			Class<T> schemaType,			List<String> attributeNames, 			Object value) throws SQLException {				// Quick return if there is not attribute to parse		final int attrNamesCount = attributeNames == null ? 0 : attributeNames.size();		if (attrNamesCount == 0) {			return;		}				final String currentAttrName = attributeNames.get(0);		ModelAttributes attributes = Schema.getAttributes(schemaType);				// Append the WHERE statement		if (attrNamesCount == 1) {			Where<T, ?> where = (Where<T, ?>) queries.get(KEY_WHERE_CLAUSE);			if (where == null) {				StatementBuilder<T, ?> sb = (StatementBuilder<T, ?>) queries.get(KEY_STATEMENT);				where = sb.where();			} else {				where = where.and();			}						try {				Method method = this.getClass().getDeclaredMethod(						operator.toUpperCase(Locale.getDefault()), 						Where.class, 						String.class, 						Object.class, 						QueryDeserializer.class, 						Type.class);								// Deserializes value of the column				final String columnName = attributes.getColumnName(currentAttrName);				Class<?> dataType = attributes.getColumnType(currentAttrName);				QueryDeserializer<?> deserializer = getDeserializer(dataType);								// It is possible to perform query on the same column with multipe				// value(s). We loop through each value and 'AND' them together				if (value instanceof List) {					int count = 0;					for (Object val : (List<Object>) value) {						if (count > 0) {							where = where.and();						}						where = (Where<T, ?>) method.invoke(this, where, columnName, val, deserializer, dataType);						count ++;					}				} else {					where = (Where<T, ?>) method.invoke(this, where, columnName, value, deserializer, dataType);				}				queries.put(KEY_WHERE_CLAUSE, where);			} catch (Exception ex) {				throw new SQLException(ERROR_SQL_SYNTAX);			}				// Continue to parse the column name		} else {			if (attributes.isForeignField(currentAttrName) || attributes.isForeignCollection(currentAttrName)) {				Class<?> foreignType = (Class<?>) attributes.getFieldGenericType(currentAttrName);				Map<String, Object> fieldQueries = (Map<String, Object>) queries.get(currentAttrName);								if (fieldQueries == null) {					// Obtain sub-queries for the given column					fieldQueries = getFieldQueryMap(foreignType);					queries.put(currentAttrName, fieldQueries);										// Left JOIN the query with the original query					QueryBuilder<?, ?> fieldQb = (QueryBuilder<?, ?>) fieldQueries.get(KEY_STATEMENT);					QueryBuilder<?, ?> currentQb = (QueryBuilder<?, ?>) queries.get(KEY_STATEMENT);					currentQb.leftJoin(fieldQb);				} 								List<String> attrNames = attributeNames.subList(1, attrNamesCount);				if (attrNames.size() == 1 && attributes.isForeignCollection(currentAttrName)) {					// Handle querying a an object which a collection of foreign objects					parseQueryArgument(operator, fieldQueries, schemaType, foreignType, attrNames.get(0), value);				} else {					parseQueryArgument(operator, fieldQueries, foreignType, attrNames, value);				}			} else {				throw new SQLException(ERROR_SQL_SYNTAX);			}		}	}	/**	 * Parses the query argument in a {@link Query} to form a {@link QueryBuilder}	 * This method parses the arguments form a query on a object that contains	 * foreign objects as specified in the argument.	 * 	 * @param <P>	 *          The parent class type	 * @param <T>	 *          The class type of the data object	 * @param operator	 *          Method object of where operation in Where class (eq, ne, gt, gte,	 *          lt, lte). This argument will not be modified.	 * @param queries	 * @param parentType	 *          The parent class type of the data object	 * @param Schema	 *          class type (usually classes inside schema package). This argument	 *          will not be modified.	 * @param attributeNames	 *          List of query strings separated by slash. e.g. ?a/b/c=1 should be	 *          ["a", "b", "c"] This argument will not be modified.	 * @param value	 *          value of query string, object type depend on the value. e.g.	 *          ?a/b/c=1 should be 1, type should be long. This argument will not	 *          be modified	 * @throws SQLException	 *           Thrown if there was an error parsing the Query object	 */	@SuppressWarnings("unchecked")	protected <P, T> void parseQueryArgument(			String operator,			Map<String, Object> queries,			Class<P> parentType,			Class<T> schemaType,			String attributeName, 			Object value) throws SQLException {				ModelAttributes attributes = Schema.getAttributes(schemaType);		Where<T, ?> where = (Where<T, ?>) queries.get(KEY_WHERE_CLAUSE);		if (where == null) {			StatementBuilder<T, ?> sb = (StatementBuilder<T, ?>) queries.get(KEY_STATEMENT);			where = sb.where();		} else {			where = where.and();		}				try {			Method method = this.getClass().getDeclaredMethod(					operator.toUpperCase(Locale.getDefault()), 					Where.class, 					String.class, 					Object.class, 					QueryDeserializer.class, 					Type.class);						// Deserializes value of the column			final String columnName = attributes.getColumnName(attributeName);			Class<?> dataType = attributes.getColumnType(attributeName);			QueryDeserializer<?> deserializer = getDeserializer(dataType);						if (value instanceof List) {				int count = 0;				for (Object val : (List<Object>) value) {					if (count > 0) {						QueryBuilder<?, ?> subQb = getQueryBuilder(schemaType);						subQb.selectColumns(attributes.getColumnName(parentType));						method.invoke(this, subQb.where(), columnName, val, deserializer, dataType);						where.and().in(attributes.getColumnName(parentType), subQb);					} else {						where = (Where<T, ?>) method.invoke(this, where, columnName, val, deserializer, dataType);					}					count ++;				}			} else {				where = (Where<T, ?>) method.invoke(this, where, columnName, value, deserializer, dataType);			}			queries.put(KEY_WHERE_CLAUSE, where);		} catch (Exception ex) {			throw new SQLException(ERROR_SQL_SYNTAX);		}	}		/**	 * Returns a {@link QueryBuilder} of a given type	 * 	 * @param <T>	 *          The class type of the data object	 * @param type	 *          The type of the data object	 * @return A {@link QueryBuilder} that can perform queries on the given data	 *         object	 * @throws SQLException	 *           Thrown if there was an error	 */	private <T> QueryBuilder<T, ?> getQueryBuilder(Class<T> type) throws SQLException {		Dao<T, ?> dao = DaoManager.createDao(connectionSource, type);		return dao.queryBuilder();	}		/**	 * Returns a {@link Map} containing the {@link QueryBuilder} for the given {@code type} and its child queries	 * 	 * @param type the type of the query	 * @return A {@link Map} containing the {@link QueryBuilder} for the given type and its child queries	 * @throws SQLException thrown if there was an error creating DAO for the given {@code type}	 */	private <T> Map<String, Object> getFieldQueryMap(Class<T> type) throws SQLException {		QueryBuilder<T, ?> fieldQb = getQueryBuilder(type);		Map<String, Object> result = new HashMap<String, Object>();		result.put(KEY_STATEMENT, fieldQb);				return result;	}		/**	 * Returns the deserializer for the given type	 * @param <T>	 * @param type the type of in which to return the deserializer	 * @return the deserializer for the given type	 */	private <T> QueryDeserializer<?> getDeserializer(TypeToken<?> type) {		QueryDeserializer<?> deserializer = deserializers.get(type);		if (deserializer != null) {			return deserializer;		}				for (QueryDeserializerFactory factory : factories) {			QueryDeserializer<?> candidate = factory.create(type);			if (candidate != null) {				deserializers.put(type, candidate);				return candidate;			}		}				return QueryDeserializers.DEFAULT;	}		/**	 * Returns the deserializer for the given type	 * @param <T>	 * @param type the type of in which to return the deserializer	 * @return the deserializer for the given type	 */	public <T> QueryDeserializer<?> getDeserializer(Class<T> type) {		return getDeserializer(TypeToken.get(type));	}		@SuppressWarnings("unused")	private <T> Where<T, ?> EQ(			Where<T, ?> where, 			String columnName, 			Object val, 			QueryDeserializer<?> deserializer, 			Type type) throws SQLException {				try {			return where.eq(columnName, deserializer.deserialize(val, type));		} catch (Exception ex) {			throw new SQLException(ERROR_SQL_SYNTAX);		}	}		@SuppressWarnings("unused")	private <T> Where<T, ?> LT(			Where<T, ?> where, 			String columnName, 			Object val, 			QueryDeserializer<?> deserializer, 			Type type) throws SQLException {				try {			return where.lt(columnName, deserializer.deserialize(val, type));		} catch (Exception ex) {			throw new SQLException(ERROR_SQL_SYNTAX);		}	}		@SuppressWarnings("unused")	private <T> Where<T, ?> GT(			Where<T, ?> where, 			String columnName, 			Object val, 			QueryDeserializer<?> deserializer, 			Type type) throws SQLException {				try {			return where.gt(columnName, deserializer.deserialize(val, type));		} catch (Exception ex) {			throw new SQLException(ERROR_SQL_SYNTAX);		}	}		@SuppressWarnings("unused")	private <T> Where<T, ?> LTE(			Where<T, ?> where, 			String columnName, 			Object val, 			QueryDeserializer<?> deserializer, 			Type type) throws SQLException {				try {			return where.le(columnName, deserializer.deserialize(val, type));		} catch (Exception ex) {			throw new SQLException(ERROR_SQL_SYNTAX);		}	}		@SuppressWarnings("unused")	private <T> Where<T, ?> GTE(			Where<T, ?> where, 			String columnName, 			Object val, 			QueryDeserializer<?> deserializer, 			Type type) throws SQLException {				try {			return where.ge(columnName, deserializer.deserialize(val, type));		} catch (Exception ex) {			throw new SQLException(ERROR_SQL_SYNTAX);		}	}		@SuppressWarnings("unused")	private <T> Where<T, ?> NE(			Where<T, ?> where, 			String columnName, 			Object val, 			QueryDeserializer<?> deserializer, 			Type type) throws SQLException {				try {			return where.ne(columnName, deserializer.deserialize(val, type));		} catch (Exception ex) {			throw new SQLException(ERROR_SQL_SYNTAX);		}	}		@SuppressWarnings("unused")	private <T> Where<T, ?> IN(			Where<T, ?> where, 			String columnName, 			Object val, 			QueryDeserializer<?> deserializer, 			Type type) throws SQLException {				try {			List<?> list = (List<?>) val;			List<Object> values = new ArrayList<Object>(list.size());			for (Object obj : list) {				values.add(deserializer.deserialize(obj, type));			}			return where.in(columnName, values);		} catch (Exception ex) {			throw new SQLException(ERROR_SQL_SYNTAX);		}	}		@SuppressWarnings("unused")	private <T> Where<T, ?> NIN(			Where<T, ?> where, 			String columnName, 			Object val, 			QueryDeserializer<?> deserializer, 			Type type) throws SQLException {				try {			List<?> list = (List<?>) val;			List<Object> values = new ArrayList<Object>(list.size());			for (Object obj : list) {				values.add(deserializer.deserialize(obj, type));			}			return where.notIn(columnName, values);		} catch (Exception ex) {			throw new SQLException(ERROR_SQL_SYNTAX);		}	}		@SuppressWarnings("unused")	private <T> Where<T, ?> NULL(			Where<T, ?> where, 			String columnName, 			Object val, 			QueryDeserializer<?> deserializer, 			Type type) throws SQLException {				try {			boolean isNull = Boolean.parseBoolean(val.toString());			if (isNull) {				return where.isNull(columnName);			} else {				return where.isNotNull(columnName);			}		} catch (Exception ex) {			throw new SQLException(ERROR_SQL_SYNTAX);		}	}		@SuppressWarnings({ "unused", "unchecked" })	private <T> Where<T, ?> BETWEEN(			Where<T, ?> where, 			String columnName, 			Object val, 			QueryDeserializer<?> deserializer, 			Type type) throws SQLException {				try {			Map<String, ?> range = (Map<String, ?>) val;			return where.between(					columnName, 					deserializer.deserialize(range.get(Query.LOW_RANGE), type), 					deserializer.deserialize(range.get(Query.HIGH_RANGE), type));		} catch (Exception ex) {			throw new SQLException(ERROR_SQL_SYNTAX);		}	}		@SuppressWarnings("unused")	private <T> Where<T, ?> LIKE(			Where<T, ?> where, 			String columnName, 			Object val, 			QueryDeserializer<?> deserializer, 			Type type) throws SQLException {				try {			Object value = deserializer.deserialize(val, type);			if (String.class.isAssignableFrom(value.getClass())) {				value = value.toString();			}			return where.like(columnName, value);		} catch (Exception ex) {			throw new SQLException(ERROR_SQL_SYNTAX);		}	}		@SuppressWarnings("unused")	private <T> Where<T, ?> NOP(			Where<T, ?> where, 			String columnName, 			Object val, 			QueryDeserializer<?> deserializer, 			Type type) throws SQLException {				// No-op operand, just return WHERE statement		return where;	}	}