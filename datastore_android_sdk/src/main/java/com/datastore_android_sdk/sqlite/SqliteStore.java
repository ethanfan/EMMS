/** * SqliteStore.java * * Copyright (c) 2008-2014 Joy Aether Limited. All rights reserved. * * Unauthorized copying of this file, via any medium is strictly prohibited. *  * This unpublished material is proprietary to Joy Aether Limited. * All rights reserved. The methods and * techniques described herein are considered trade secrets * and/or confidential. Reproduction or distribution, in whole * or in part, is forbidden except by express written permission * of Joy Aether Limited. */package com.datastore_android_sdk.sqlite;import static com.google.common.base.Preconditions.checkNotNull;import java.lang.reflect.Field;import java.sql.SQLException;import java.util.ArrayList;import java.util.Arrays;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;import org.jasypt.util.password.PasswordEncryptor;import org.restlet.security.User;import com.datastore_android_sdk.DatastoreException.DatastoreException;import com.datastore_android_sdk.DatastoreException.NotAuthorizedException;import com.datastore_android_sdk.DatastoreException.ResourceNotFoundException;import com.datastore_android_sdk.callback.AuthorizationCallback;import com.datastore_android_sdk.callback.StoreCallback;import com.datastore_android_sdk.datastore.DataElement;import com.datastore_android_sdk.datastore.Datastore;import com.datastore_android_sdk.datastore.ObjectElement;import com.datastore_android_sdk.datastore.PrimitiveElement;import com.datastore_android_sdk.datastore.Store;import com.datastore_android_sdk.rest.JsonObjectElement;import com.datastore_android_sdk.schema.Log;import com.datastore_android_sdk.schema.Model;import com.datastore_android_sdk.schema.PasswordField;import com.datastore_android_sdk.schema.Query;import com.datastore_android_sdk.schema.Schema;import com.datastore_android_sdk.security.IdToken;import com.datastore_android_sdk.serialization.ForeignCollectionInstanceCreator;import com.datastore_android_sdk.serialization.ModelSerializationPolicy;import com.datastore_android_sdk.serialization.ModelSerializationStrategy;import com.google.common.util.concurrent.FutureCallback;import com.google.common.util.concurrent.Futures;import com.google.common.util.concurrent.ListenableFuture;import com.google.common.util.concurrent.ListeningExecutorService;import com.google.common.util.concurrent.MoreExecutors;import com.google.gson.JsonElement;import com.google.gson.JsonParser;import com.j256.ormlite.dao.CloseableIterator;import com.j256.ormlite.dao.Dao;import com.j256.ormlite.dao.DaoManager;import com.j256.ormlite.dao.GenericRawResults;import com.j256.ormlite.misc.TransactionManager;import com.j256.ormlite.stmt.UpdateBuilder;import com.j256.ormlite.support.ConnectionSource;import com.datastore_android_sdk.schema.ModelAttributes;/** * A SQLite implementation of datastore that provides access to the SQLite databases. */public class SqliteStore implements Store {		/** The default constants. */	private static final long DEFAULT_TIMEOUT = 2;		/** The thread pool to execute REST requests. */	private final ListeningExecutorService executors;		/** The helper object that provides access to the underlying database. */	private DatabaseOpenHelper helper;		/**	 * Construct a new {@link SqliteStore} with the given {@link DatabaseOpenHelper}.	 * 	 * @param helper The helper object that provides access to database	 */	public SqliteStore(DatabaseOpenHelper helper) {		this(helper, Executors.newCachedThreadPool());	}		/**	 * Creates a new instance of {@link SqliteStore} with the given	 * {@link DatabaseOpenHelper} and executor to execute queries.	 * 	 * @param helper The helper object that provides access to database	 * @param executor The {@link ExecutorService} to execute queries	 */	public SqliteStore(DatabaseOpenHelper helper, ExecutorService executor) {		checkNotNull(helper, "Database helper cannot be null.");		checkNotNull(executor, "Must specify an executor to execute queries");				this.helper = helper;		this.executors = executor instanceof ListeningExecutorService ? (ListeningExecutorService) executor : MoreExecutors.listeningDecorator(executor);	}		/**	 * Returns the helper object that provides access to the database.	 * 	 * @return The helper object that provides access to the database	 */	public synchronized DatabaseOpenHelper getHelper() {		return helper;	}	/**	 * Returns the helper that manages database creation and upgrade.	 * 	 * @return The {@link SqliteStoreHelper} that manages database creation,	 *         upgrade and schema	 */	protected SqliteStoreHelper getStoreHelper() {		return getHelper() == null ? null : getHelper().getStoreHelper();	}	/**	 * Returns the execution service that this client can use to schedule request	 * tasks.	 * 	 * @return The execution service to schedule request tasks	 */	protected ListeningExecutorService getExecutor() {		return executors;	}		/**	 * Returns the class type of the given resource.	 * 	 * @param resource The name of the resource 	 * @return The class type of the resource	 */	protected Class<?> getResourceClass(String resource) {		SqliteStoreHelper storeHelper = getStoreHelper();		return storeHelper == null ? null : storeHelper.getSchema(resource);	}	@Override	public ListenableFuture<DataElement> createElement(final DataElement element, final String resource, final StoreCallback callback) {		Callable<DataElement> task = new Callable<DataElement>() {			@SuppressWarnings({ "unchecked", "rawtypes" })			@Override			public DataElement call() throws Exception {				DataElement result = null;								final boolean isOrmIterable = element instanceof OrmCollectionElement || element instanceof OrmIterableElement;				final OrmCollectionElement collection = new OrmCollectionElement(new ArrayList());				final OrmObjectElement objectResult = new OrmObjectElement();								TransactionManager.callInTransaction(getHelper().getConnectionSource(), new Callable<Void>() {										@Override					public Void call() throws Exception {						Iterator<DataElement> iterator = null;						try {							Class<?> clazz = getResourceClass(resource);														if (element.isObject()) {								ModelAttributes attrs = Schema.getAttributes(clazz);								Class<?> idType = attrs.getColumnType(attrs.getIdField());								objectResult.model = createObjectElement(element.asObjectElement(), (Class<Model>) clazz, idType);							} else if (element.isArray()) {								iterator = element.asArrayElement().iterator();																while (iterator.hasNext()) {									DataElement e = iterator.next();									if (e.isObject()) {										ModelAttributes attrs = Schema.getAttributes(clazz);										Class<?> idType = attrs.getColumnType(attrs.getIdField());										Model model = createObjectElement(e.asObjectElement(), (Class<Model>) clazz, idType);																				// Adds the model created into an ORM collection										if (!isOrmIterable) {											collection.add(new OrmObjectElement(model));										}									}								}							}														} finally {							// We closes the iterator if it was closeable							if (iterator instanceof CloseableIterator) {								((CloseableIterator) iterator).close();							}						}												return null;					}									});								// Return the data element created				if (element.isObject()) {					result = objectResult;				} else if (element.isArray()) {												if (isOrmIterable) {						result = element;					} else {						result = collection;					}				}				return result;			}					};				ListenableFuture<DataElement> future = getExecutor().submit(task);		if (callback != null) {						Futures.addCallback(future, new FutureCallback<DataElement>() {								@Override				public void onSuccess(DataElement result) {					callback.success(result, resource);				}								@Override				public void onFailure(Throwable t) {					callback.failure(t instanceof DatastoreException ? (DatastoreException) t : new DatastoreException(t), resource);				}										});		}		return future;	}	@Override	public ListenableFuture<DataElement> readElement(final Object id, final String resource, final StoreCallback callback) {		Callable<DataElement> task = new Callable<DataElement>() {			@SuppressWarnings({ "unchecked", "rawtypes" })			@Override			public DataElement call() throws Exception {				DataElement result = null;				try {					Class<?> clazz = getResourceClass(resource);					Model<?, ?> model = (Model<?, ?>) Model.find(getHelper().getConnectionSource(), clazz, id);					if (model == null) {						throw new ResourceNotFoundException(resource, id == null ? null : id.toString());					} else {						result = new OrmObjectElement(model);					}				} catch (Exception ex) {					throw new DatastoreException(ex);				}				return result;			}					};		ListenableFuture<DataElement> future = getExecutor().submit(task);		if (callback != null) {						Futures.addCallback(future, new FutureCallback<DataElement>() {								@Override				public void onSuccess(DataElement result) {					callback.success(result, resource);				}								@Override				public void onFailure(Throwable t) {					callback.failure(t instanceof DatastoreException ? (DatastoreException) t : new DatastoreException(t), resource);				}										});		}		return future;	}	@Override	public ListenableFuture<DataElement> updateElement(final Object id, final DataElement element, final String resource, final StoreCallback callback) {		Callable<DataElement> task = new Callable<DataElement>() {			@Override			public DataElement call() throws Exception {				try {					TransactionManager.callInTransaction(getHelper().getConnectionSource(), new Callable<DataElement>() {						@SuppressWarnings({ "rawtypes", "unchecked" })						@Override						public DataElement call() throws Exception {							Model model = null;							Class<?> clazz = getResourceClass(resource);														if (element.isObject()) {								ModelAttributes attrs = Schema.getAttributes(clazz);								Class<?> idType = attrs.getColumnType(attrs.getIdField());								model = updateObjectElement(id, element.asObjectElement(), (Class<Model>) clazz, idType);								// Invoke callback								ObjectElement result = element instanceof OrmObjectElement ? (OrmObjectElement) element.asObjectElement() : new OrmObjectElement(model);								return result;							} else if (element.isArray()) {								boolean isOrmIterable = element instanceof OrmCollectionElement || element instanceof OrmIterableElement;								OrmCollectionElement collection = null;								Iterator<DataElement> iterator = element.asArrayElement().iterator();																while (iterator.hasNext()) {									DataElement e = iterator.next();									if (e.isObject()) {										ModelAttributes attrs = Schema.getAttributes(clazz);										Class<?> idType = attrs.getColumnType(attrs.getIdField());										model = updateObjectElement(id, e.asObjectElement(), (Class<Model>) clazz, idType);																				// Adds the model created into an ORM collection										if (!isOrmIterable) {											if (collection == null) {												collection = new OrmCollectionElement(new ArrayList());											}											collection.add(new OrmObjectElement(model));										}									}								}																		// We closes the iterator if it was closeable								if (iterator instanceof CloseableIterator) {									((CloseableIterator) iterator).close();								}																// Invoke callback								if (isOrmIterable) {									return element;								} else {									return collection;								}							}							return null;						}											});										return element;				} catch (Exception ex) {					throw new DatastoreException(ex);				}			}					};		ListenableFuture<DataElement> future = getExecutor().submit(task);		if (callback != null) {						Futures.addCallback(future, new FutureCallback<DataElement>() {								@Override				public void onSuccess(DataElement result) {					callback.success(result, resource);				}								@Override				public void onFailure(Throwable t) {					callback.failure(t instanceof DatastoreException ? (DatastoreException) t : new DatastoreException(t), resource);				}										});		}		return future;	}		@Override	public ListenableFuture<DataElement> updateElements(final Query query, final DataElement element, final String resource, final StoreCallback callback) {		Callable<DataElement> task = new Callable<DataElement>() {			@Override			public DataElement call() throws Exception {				Callable<DataElement> callable = new Callable<DataElement>() {										@Override					public DataElement call() throws Exception {						if (element.isObject()) {							HashMap<String, Object> keyValues = new HashMap<String, Object>();							ObjectElement object = element.asObjectElement();							for (String key : object.allKeys()) {								DataElement e = object.get(key);								if (e.isPrimitive()) {									PrimitiveElement p = e.asPrimitiveElement();									if (p.isBoolean()) {																					keyValues.put(key, p.valueAsBoolean());									} else if (p.isNumber()) {										keyValues.put(key, p.valueAsNumber());									} else if (p.isString()) {										keyValues.put(key, p.valueAsString());									}								} else if (e.isNull()) {									keyValues.put(key, null);								}							}														int udpated = Model.udpate(									getHelper().getConnectionSource(), 									getResourceClass(resource), 									keyValues, 									query, 									null);							return new OrmPrimitiveElement(Integer.valueOf(udpated));						}												// Nothing to update						return new OrmPrimitiveElement(0L);					}									};								return TransactionManager.callInTransaction(getHelper().getConnectionSource(), callable);			}					};		ListenableFuture<DataElement> future = getExecutor().submit(task);		if (callback != null) {						Futures.addCallback(future, new FutureCallback<DataElement>() {								@Override				public void onSuccess(DataElement result) {					callback.success(result, resource);				}								@Override				public void onFailure(Throwable t) {					callback.failure(t instanceof DatastoreException ? (DatastoreException) t : new DatastoreException(t), resource);				}						});		}		return future;	}	@Override	public ListenableFuture<DataElement> deleteElement(final Object id, final String resource, final StoreCallback callback) {		Callable<DataElement> task = new Callable<DataElement>() {			@SuppressWarnings("rawtypes")			@Override			public DataElement call() throws Exception {				DataElement result = null;				try {					Class<?> clazz = getResourceClass(resource);					ConnectionSource cs = getHelper().getConnectionSource();					final Model model = (Model) Model.find(cs, clazz, id);										if (model != null) {						TransactionManager.callInTransaction(cs, new Callable<Void>() {							@Override							public Void call() throws Exception {								createLog(model, Log.Action.DELETE);								model.delete();								return null;							}													});												return result;					} else {						// The data item specified is not found						throw new ResourceNotFoundException(resource, id == null ? null : id.toString());					}				} catch (Exception ex) {					throw new DatastoreException(ex);				}			}					};		ListenableFuture<DataElement> future = getExecutor().submit(task);		if (callback != null) {						Futures.addCallback(future, new FutureCallback<DataElement>() {								@Override				public void onSuccess(DataElement result) {					callback.success(result, resource);				}								@Override				public void onFailure(Throwable t) {					callback.failure(t instanceof DatastoreException ? (DatastoreException) t : new DatastoreException(t), resource);				}										});		}		return future;	}	@Override	public ListenableFuture<DataElement> deleteElements(final Query query, final String resource, final StoreCallback callback) {		Callable<DataElement> task = new Callable<DataElement>() {			@SuppressWarnings({ "rawtypes", "unchecked" })			@Override			public DataElement call() throws Exception {				try {					final Class<?> clazz = getResourceClass(resource);					final ConnectionSource cs = getHelper().getConnectionSource();										TransactionManager.callInTransaction(cs, new Callable<Void>() {						@Override						public Void call() throws Exception {							List<Model> collection = null;							SqliteStoreHelper storeHelper = getHelper().getStoreHelper();							boolean loggingEnabled = storeHelper == null ? false : storeHelper.isLoggingEnabled();														if (loggingEnabled) {								collection = (List<Model>) Model.find(cs, clazz, query);							}														Model.delete(cs, (Class<Model>) clazz, query);														if (loggingEnabled && collection != null) {								for (Model model : collection) {									createLog(model, Log.Action.DELETE);								}							}							return null;						}											});										return null;				} catch (Exception ex) {					throw new DatastoreException(ex);				}			}					};		ListenableFuture<DataElement> future = getExecutor().submit(task);		if (callback != null) {						Futures.addCallback(future, new FutureCallback<DataElement>() {								@Override				public void onSuccess(DataElement result) {					callback.success(result, resource);				}								@Override				public void onFailure(Throwable t) {					callback.failure(t instanceof DatastoreException ? (DatastoreException) t : new DatastoreException(t), resource);				}										});		}		return future;	}	@Override	public ListenableFuture<DataElement> performQuery(final Query query, final String resource, final StoreCallback callback) {		Callable<DataElement> task = new Callable<DataElement>() {			@SuppressWarnings({ "rawtypes", "unchecked" })			@Override			public DataElement call() throws Exception {				DataElement result = null;				try {					Class<?> clazz = getResourceClass(resource);						OrmIterableElement element = new OrmIterableElement(Model.fetch(getHelper().getConnectionSource(), clazz, query));						if (query != null) {														ModelSerializationStrategy serializationStrategy = ModelSerializationPolicy.DEFAULT									.disableIdFieldOnlySerialization()									.withExpansionTree(query.getExpandingFields())									.withSelectingFields(query.getSelectFields());							element.setSerializationStrategy(serializationStrategy);						}						result = element;				} catch (Exception ex) {					throw new DatastoreException(ex);				}				return result;				}		};		ListenableFuture<DataElement> future = getExecutor().submit(task);		if (callback != null) {						Futures.addCallback(future, new FutureCallback<DataElement>() {								@Override				public void onSuccess(DataElement result) {					callback.success(result, resource);				}								@Override				public void onFailure(Throwable t) {					callback.failure(t instanceof DatastoreException ? (DatastoreException) t : new DatastoreException(t), resource);				}										});		}		return future;	}		@Override	public ListenableFuture<DataElement> count(final Query query, final String resource, final StoreCallback callback) {		Callable<DataElement> task = new Callable<DataElement>() {			@Override			public DataElement call() throws Exception {				DataElement result = null;				try {					Class<?> clazz = getResourceClass(resource);					long count = Model.countOf(getHelper().getConnectionSource(), clazz, query);					result = new OrmPrimitiveElement(count);				} catch (Exception ex) {					throw new DatastoreException(ex);				}				return result;			}					};		ListenableFuture<DataElement> future = getExecutor().submit(task);		if (callback != null) {						Futures.addCallback(future, new FutureCallback<DataElement>() {								@Override				public void onSuccess(DataElement result) {					callback.success(result, resource);				}								@Override				public void onFailure(Throwable t) {					callback.failure(t instanceof DatastoreException ? (DatastoreException) t : new DatastoreException(t), resource);				}										});		}		return future;	}		@Override	public ListenableFuture<DataElement> updateAtomicField(			final Object id, 			final String resource, 			final Datastore.AtomicOperation operation,			final StoreCallback callback) {				return updateAtomicFields(id, resource, Arrays.asList(operation), callback);	}		@Override	public ListenableFuture<DataElement> updateAtomicFields(			final Object id, 			final String resource, 			final List<Datastore.AtomicOperation> operations,			final StoreCallback callback) {				Callable<DataElement> task = new Callable<DataElement>() {			@SuppressWarnings({ "rawtypes", "unchecked" })			@Override			public DataElement call() throws Exception {				try {					final ConnectionSource cs = getHelper().getConnectionSource();					TransactionManager.callInTransaction(cs, new Callable<DataElement>() {						@Override						public DataElement call() throws Exception {							Class<?> clazz = getResourceClass(resource);							Dao dao = DaoManager.createDao(cs, clazz);														UpdateBuilder updateBuilder = dao.updateBuilder();							for (Datastore.AtomicOperation operation : operations) {								updateBuilder.updateColumnExpression(										operation.getField(), 										updateBuilder.escapeColumnName(operation.getField()) + " " + operation.getValue());													}							updateBuilder.where().idEq(id);							updateBuilder.update();														Model model = (Model) Model.find(cs, clazz, id);							return new OrmObjectElement(model);						}											});				} catch (Exception ex) {					throw new DatastoreException(ex);				}				return null;			}					};		ListenableFuture<DataElement> future = getExecutor().submit(task);		if (callback != null) {						Futures.addCallback(future, new FutureCallback<DataElement>() {								@Override				public void onSuccess(DataElement result) {					callback.success(result, resource);				}								@Override				public void onFailure(Throwable t) {					callback.failure(t instanceof DatastoreException ? (DatastoreException) t : new DatastoreException(t), resource);				}										});		}		return future;	}		@Override	public ListenableFuture<IdToken> login(final String username, final String password, final AuthorizationCallback callback) {		final SqliteStoreHelper storeHelper = getHelper().getStoreHelper();		if (storeHelper != null && storeHelper.getCredentialSchema() != null) {			Callable<IdToken> task = new Callable<IdToken>() {				@Override				public IdToken call() throws Exception {					Class<? extends User> clazz = storeHelper.getCredentialSchema();					final ModelAttributes attrs = Schema.getAttributes(clazz);										// Find the given credentials from store					DataElement element = readElement(username, attrs.getTableName(), null).get(DEFAULT_TIMEOUT, TimeUnit.SECONDS);					if (element != null && element.isObject()) {						String passwordField = null;												// Find the password field						List<String> passwordFields = attrs.getPasswordFields();						for (String fieldName : passwordFields) {							if (attrs.isPasswordField(fieldName) && !attrs.isTemporaryPasswordField(fieldName)) {								passwordField = fieldName;								break;							}						}												try {							DataElement pwd = element.asObjectElement().get(passwordField);							Field field = attrs.getColumns().get(passwordField);							PasswordEncryptor encryptor = getPasswordEncryptor(field);														boolean match = false;							if (encryptor == null) {								// Plain text secret								if (pwd.isNull()) {									match = password == null;								} else {									match = pwd.asPrimitiveElement().valueAsString().equals(password);								}							} else {								match = encryptor.checkPassword(password, pwd.asPrimitiveElement().valueAsString());							}														if (match) {								// FIXME: generate an ID token								return null;							} else {								throw new NotAuthorizedException(username + " is not authorized.");							}						} catch (Exception ex) {							throw new NotAuthorizedException(ex);						}					} else {						throw new NotAuthorizedException(username + " is not authorized.");					}				}							};			ListenableFuture<IdToken> future = getExecutor().submit(task);			if (callback != null) {								Futures.addCallback(future, new FutureCallback<IdToken>() {										@Override					public void onSuccess(IdToken resultToken) {						callback.success(resultToken);					}										@Override					public void onFailure(Throwable t) {						callback.failure(t instanceof DatastoreException ? (DatastoreException) t : new DatastoreException(t));					}									});			}			return future;					} else {			DatastoreException e = new DatastoreException("Credentials authentication is not supported.");			if (callback != null) {				callback.failure(e);			}			return Futures.immediateFailedFuture(e);		}	}		@Override	public ListenableFuture<?> logout(final AuthorizationCallback callback) {		Callable<Boolean> task = new Callable<Boolean>() {			@Override			public Boolean call() throws Exception {				// Invoke the failure callback if credential authentication is not supported				SqliteStoreHelper storeHelper = getHelper().getStoreHelper();				if (storeHelper != null && storeHelper.getCredentialSchema() != null) {					// No-op. Maintainence of the ID token is out of scope of the store					return true; 				} else {					throw new DatastoreException("Credentials authentication is not supported.");				}			}		};		ListenableFuture<Boolean> future = getExecutor().submit(task);		if (callback != null) {						Futures.addCallback(future, new FutureCallback<Boolean>() {								@Override				public void onSuccess(Boolean result) {					callback.success(null);				}								@Override				public void onFailure(Throwable t) {					callback.failure(t instanceof DatastoreException ? (DatastoreException) t : new DatastoreException(t));				}							});		}		return future;	}	/**	 * Perform the given {@code query} with the {@code arguments}.	 * 	 * <p>	 * <b>Note:</b> This method should be avoided for queries that return a large	 * data set. This method will load the entire result set into memory.	 * </p>	 * 	 * @param query	 *          The raw query to perform on the store	 * @param resource	 *          The resource the query to perform on	 * @param callback	 *          The callback to be invoked when the operation completes	 * @param arguments	 *          The arguments to pass into the query	 */	public ListenableFuture<DataElement> performRawQuery(final String query, final String resource, final StoreCallback callback, final String... arguments) {		Callable<DataElement> task = new Callable<DataElement>() {			@SuppressWarnings({ "rawtypes", "unchecked" })			@Override			public DataElement call() throws Exception {				DataElement result = null;				try {					Class<?> clazz = getResourceClass(resource);					Dao dao = DaoManager.createDao(getHelper().getConnectionSource(), clazz);					GenericRawResults<String[]> results = dao.queryRaw(query, arguments);					result = new OrmRawResultsElement(results.getColumnNames(), results.getResults());				} catch (Exception ex) {					throw new DatastoreException(ex);				}				return result;			}					};		ListenableFuture<DataElement> future = getExecutor().submit(task);		if (callback != null) {						Futures.addCallback(future, new FutureCallback<DataElement>() {								@Override				public void onSuccess(DataElement result) {					callback.success(result, resource);				}								@Override				public void onFailure(Throwable t) {					callback.failure(t instanceof DatastoreException ? (DatastoreException) t : new DatastoreException(t), resource);				}										});		}		return future;	}		/**	 * Returns the {@link PasswordEncryptor} to verify credentials secrets.	 * 	 * @param <E> The type that implemented the {@link PasswordEncryptor} interface 	 * @return The {@link PasswordEncryptor} to verify credentials secrets, {@code null} if no encryptor is defined	 */	@SuppressWarnings("unchecked")	protected <E extends PasswordEncryptor> E getPasswordEncryptor(Field field) {		PasswordEncryptor result = null;				try {			PasswordField pwdField = field == null ? null : field.getAnnotation(PasswordField.class);			result = pwdField == null ? null : pwdField.encryptorClass().newInstance();		} catch (Exception ex) {			// Ignored. No password encryptor is defined.		}				return (E) result;	}	/**	 * Updates the data object in the database.	 * 	 * @param <T>	 *          The class type of the data model to create	 * @param <ID>	 *          The Java type of the ID of the data model	 * @param id	 *          The identifier of the element to update	 * @param element	 *          The data element to create in the SQLite database	 * @param clazz	 *          The class type of the data model	 * @param idType	 *          The Java type of the ID of the data model	 * @throws DatastoreException	 *           Thrown if there was an exception	 */	@SuppressWarnings({ "unchecked", "rawtypes" })	protected <T extends Model<T, ID>, ID> T updateObjectElement(			Object id,			ObjectElement element, 			Class<T> clazz, 			Class<ID> idType) throws DatastoreException {				T result = null;		try {			if (element instanceof OrmObjectElement) {				T model = (T) ((OrmObjectElement) element).model;				String idField = Schema.getAttributes(model.getClass()).getIdField();				Object identifier = model.getFieldValue(idField);								if (identifier != null && identifier.equals(id)) {					// We are updating the data model directly					Dao<T, ID> dao = DaoManager.createDao(getHelper().getConnectionSource(), clazz);					model.setDao(dao);					model.update();					createLog(model, Log.Action.UPDATE);					result = model;				} else {					// We are trying to update a data record in the database to values as					// specified in data model					updateObjectElement(id, new JsonObjectElement(element.toJson()), clazz, idType);				}			} else {				String json = element == null ? "" : element.toJson();				JsonElement jsonElement = new JsonParser().parse(json);				if (jsonElement.isJsonObject()) {					ConnectionSource cs = getHelper().getConnectionSource();					T model = Model.find(cs, clazz, id);					model.update(jsonElement.getAsJsonObject(), new ForeignCollectionInstanceCreator(cs));					createLog(model, Log.Action.UPDATE);					result = model;				}			}		} catch (Exception ex) {			// Wraps the exception and re-throw the exception			throw new DatastoreException(ex);		}				return result;	}	/**	 * Creates the data object in the database.	 * 	 * @param <T>	 *          The class type of the data model to create	 * @param <ID>	 *          The Java type of the ID of the data model	 * @param element	 *          The data element to create in the SQLite database	 * @param clazz	 *          The class type of the data model	 * @param idType	 *          The Java type of the ID of the data model	 * @throws DatastoreException	 *           Thrown if there was an exception	 */	@SuppressWarnings({ "unchecked", "rawtypes" })	protected <T extends Model<T, ID>, ID> T createObjectElement(			ObjectElement element, 			Class<T> clazz, 			Class<ID> idType) throws DatastoreException {				T result = null;		try {			Model.Callback callback = new Model.Callback() {				@Override				public void created(Model<?, ?> model) throws SQLException {					try {						createLog(model, Log.Action.CREATE);					} catch (Exception ex) {						// Ignored					}				}				@Override				public void updated(Model<?, ?> model) {					try {						createLog(model, Log.Action.UPDATE);					} catch (Exception ex) {						// Ignored					}				}				@Override				public void beforeCreate(Model<?, ?> model) throws SQLException {					// No-op				}				@Override				public void beforeUpdate(Model<?, ?> model) {					// No-op				}			};						Dao<T, ID> dao = DaoManager.createDao(getHelper().getConnectionSource(), clazz);			if (element instanceof OrmObjectElement) {				T model = (T) ((OrmObjectElement) element).model;				model.setDao(dao);				model.createOrUpdate(						null,						((OrmObjectElement) element).getSerializationStrategy(),						callback);				result = model;			} else {				String json = element.toJson();				JsonElement jsonElement = new JsonParser().parse(json);				if (jsonElement.isJsonObject()) {					T model = Model.fromJson(							jsonElement.getAsJsonObject(), 							new ForeignCollectionInstanceCreator(getHelper().getConnectionSource()), 							clazz);					model.setDao(dao);					model.createOrUpdate(							null, 							jsonElement.getAsJsonObject(), 							callback);					result = model;				}			}		} catch (Exception ex) {			// Wraps the exception and re-throw the exception			throw new DatastoreException(ex);		}				return result;	}	/**	 * Creates a log entry in the database for the given action taken.	 * 	 * @param model	 *          The data the action performed on	 * @param action	 *          The action performed	 * @throws SQLException Thrown if the log entry cannot be created	 */	protected void createLog(Model<?, ?> model, Log.Action action) throws SQLException {		SqliteStoreHelper storeHelper = getHelper().getStoreHelper();		if (storeHelper != null && storeHelper.isLoggingEnabled()) {			Model<?, ?> log = storeHelper.getLog(model, action);			if (log != null) {				log.create(getHelper().getConnectionSource());			}		}	}}