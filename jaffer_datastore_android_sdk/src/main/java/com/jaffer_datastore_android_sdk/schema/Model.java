/** * Model.java * * Copyright (c) 2008-2014 Joy Aether Limited. All rights reserved. * * Unauthorized copying of this file, via any medium is strictly prohibited. *  * This unpublished material is proprietary to Joy Aether Limited. * All rights reserved. The methods and * techniques described herein are considered trade secrets * and/or confidential. Reproduction or distribution, in whole * or in part, is forbidden except by express written permission * of Joy Aether Limited. */package com.jaffer_datastore_android_sdk.schema;import java.io.Reader;import java.io.StringReader;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Type;import java.sql.SQLException;import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.Collections;import java.util.Date;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.regex.Matcher;import java.util.regex.Pattern;import org.jasypt.util.password.PasswordEncryptor;import com.google.gson.FieldNamingPolicy;import com.google.gson.FieldNamingStrategy;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.InstanceCreator;import com.google.gson.JsonArray;import com.google.gson.JsonElement;import com.google.gson.JsonIOException;import com.google.gson.JsonObject;import com.google.gson.JsonParseException;import com.google.gson.JsonPrimitive;import com.google.gson.JsonSyntaxException;import com.google.gson.internal.ConstructorConstructor;import com.google.gson.internal.Excluder;import com.google.gson.internal.bind.JsonTreeReader;import com.google.gson.stream.JsonReader;import com.j256.ormlite.dao.CloseableIterator;import com.j256.ormlite.dao.CloseableWrappedIterable;import com.j256.ormlite.dao.Dao;import com.j256.ormlite.dao.DaoManager;import com.j256.ormlite.dao.ForeignCollection;import com.j256.ormlite.dao.LazyForeignCollection;import com.j256.ormlite.misc.BaseDaoEnabled;import com.j256.ormlite.stmt.DeleteBuilder;import com.j256.ormlite.stmt.QueryBuilder;import com.j256.ormlite.stmt.StatementBuilder;import com.j256.ormlite.stmt.UpdateBuilder;import com.j256.ormlite.support.ConnectionSource;import com.jaffer_datastore_android_sdk.DatastoreException.DatastoreException;import com.jaffer_datastore_android_sdk.DatastoreException.VersionConflictException;import com.jaffer_datastore_android_sdk.serialization.DateTypeAdapter;import com.jaffer_datastore_android_sdk.serialization.ForeignCollectionInstanceCreator;import com.jaffer_datastore_android_sdk.serialization.ForeignCollectionTypeAdapterFactory;import com.jaffer_datastore_android_sdk.serialization.ModelSerializationPolicy;import com.jaffer_datastore_android_sdk.serialization.ModelSerializationStrategy;import com.jaffer_datastore_android_sdk.serialization.ModelTypeAdapterFactory;/** * The Model object that represents an object in the underlying datastore. *  * @author Stanley Lam * @param <T> the type of the data object * @param <ID> the type of the identity of the data object */@SuppressWarnings("deprecation")public abstract class Model<T, ID> extends BaseDaoEnabled<T, ID> implements Cloneable {	// for QueryBuilder to be able to find the fields	public static final String CREATED_DATE_FIELD_NAME = "createddate";	public static final String LAST_MODIFIED_DATE_FIELD_NAME = "lastmoddate";		/** A boolean that indicates whether refresh had ever been called on the data model. */	private transient boolean refreshed = false;	/**	 * Defines the callbacks to be invoked when a before and after a data object	 * is created or updated.	 */	public interface Callback {		/**		 * Called before create a data model in the underlying data store.		 * 		 * @param model		 *          the data model going to create		 * @throws SQLException		 *           Thrown if there was error		 */		void beforeCreate(Model<?, ?> model) throws SQLException;		/**		 * Called after a data model was created in the underlying data store.		 * 		 * @param model		 *          the data model created		 * @throws SQLException		 *           Thrown if there was error executing the callback		 */		void created(Model<?, ?> model) throws SQLException;		/**		 * Called before update a data model in the underlying data store.		 * 		 * @param model		 *          the data model going to update		 */		void beforeUpdate(Model<?, ?> model);		/**		 * Called after a data model was updated in the underlying data store.		 * 		 * @param model		 *          the data model updated		 */		void updated(Model<?, ?> model);	}	/**	 * This constructor should only be called by sub-classes.	 */	protected Model() { }	/**	 * Creates and returns a copy of this object.	 * 	 * @return the copy of this object	 */	@SuppressWarnings({ "rawtypes" })	@Override	public Model clone() {		try {			return (Model) super.clone();		} catch (CloneNotSupportedException e) {			throw new AssertionError(e);		}	}	/**	 * Returns the underlying value of the Field with the given name.	 * 	 * @param fieldName	 *          the name of the field	 * @return the underlying value of the field, null if the field could not be	 *         found	 */	public Object getFieldValue(String fieldName) {		List<String> fieldComponents = Arrays.asList(fieldName.split("/"));		try {			return getFieldValue(fieldComponents);		} catch (DatastoreException ex) {			// Ignores any error that may occur while accessing the field. We return			// {@code null} by default		}		return null;	}		/**	 * Returns the underlying value of the Field with the given name.	 * 	 * @param fieldComponents	 *            a list containing, in order, each field component	 * @param strategy	 *            the serialization strategy that determines whether or not a	 *            field should be refreshed	 * @return the underlying value of the field	 * @throws DatastoreException	 *             Thrown if there was error accessing the field	 */	@SuppressWarnings({ "unchecked", "rawtypes" })	public Object getFieldValue(List<String> fieldComponents, ModelSerializationStrategy policy) throws DatastoreException {		Object result = null;		try {			String fieldName = fieldComponents.get(0);			int index = -1;			Pattern p = Pattern.compile("(.+?)\\[(.*?)\\]");			Matcher m = p.matcher(fieldName);			// if the pattern: paramName[index] was found			if (m.find() && m.groupCount() == 2) {				fieldName = m.group(1);				index = Integer.valueOf(m.group(2));			}			Field field = Schema.getAttributes(getClass()).getAllFields().get(fieldName);			field.setAccessible(true);			Object object = field.get(this);			if (fieldComponents.size() == 1) {				if (policy.shouldRefreshField(field) && object instanceof Model) {					((Model) object).refresh();				}				result = object;			} else if (fieldComponents.size() > 1) {				boolean isForeign = Schema.getAttributes(getClass()).isForeignField(fieldName);				boolean isForeignCollection = Schema.getAttributes(getClass()).isForeignCollection(fieldName);				boolean isLazy = false;				if (isForeign || isForeignCollection) {					if (isForeignCollection) {						isLazy = object instanceof LazyForeignCollection;						ForeignCollection<?> col = (ForeignCollection<?>) object;												if (index > -1 && col.size() < index) {							CloseableWrappedIterable<?> iterable = col.getWrappedIterable();							Iterator<?> itr = iterable.iterator();							int i = 0;														while (itr.hasNext()) {								Object obj = itr.next();								if (i == index) {									object = obj;									break;								}								i++;							}														try {								iterable.close();							} catch (Exception e) {								// Ignore							}						} else {							// Index out of bound, return {@code null}							object = null;						}					}					if (object instanceof Model) {						List<String> fieldPath = fieldComponents.subList(1, fieldComponents.size());						if (isLazy) {							((Model) object).refresh(getFieldPathComponents(fieldPath));						} else if (policy.shouldRefreshField(field) && !refreshed()) {							((Model) object).refresh();						}						result = ((Model) object).getFieldValue(fieldPath, policy.getFieldSerializationStrategy(field));					}				}			}		} catch (Exception ex) {			throw new DatastoreException(ex);		}		return result;	}	/**	 * Returns the underlying value of the Field with the given name.	 * 	 * @param fieldComponents	 *          a list containing, in order, each field component	 * @return the underlying value of the field	 * @throws DatastoreException	 *           Thrown if there was error accessing the field	 */	public Object getFieldValue(List<String> fieldComponents) throws DatastoreException {		return getFieldValue(fieldComponents, ModelSerializationPolicy.DEFAULT.disableIdFieldOnlySerialization());	}	/**	 * Sets the field represented by the field object with the given name.	 * 	 * @param fieldName	 *          the name of the field	 * @param value	 *          the value of the field	 */	public void setFieldValue(String fieldName, Object value) {		try {			ModelAttributes attributes = Schema.getAttributes(getClass());			Field field = attributes.getAllFields().get(fieldName);			if (field != null) {								if (attributes.isPasswordField(fieldName)) {					setPasswordFieldValue(field, value);				} else {					field.setAccessible(true);					field.set(this, value);				}			}		} catch (Exception ex) {			// ignores any error that may occur while accessing the field		}	}	/**	 * Sets the password field represented by the field object.	 * 	 * @param f	 *          the password field	 * @param value	 *          the value of the field	 */	protected void setPasswordFieldValue(Field f, Object value) {		if (f != null) {						try {				Object password = value;				if (password != null) {					PasswordField pwdField = f.getAnnotation(PasswordField.class);					PasswordEncryptor encryptor = pwdField.encryptorClass().newInstance();					password = encryptor.encryptPassword(password.toString());				}								f.setAccessible(true);				f.set(this, password);			} catch (Exception ex) {				// Ignored			}		}	}	/**	 * Returns the type adapter factory to use for JSON de/serialization of the	 * data model for the given data model.	 * 	 * @return the type adapter factory to use during serialization	 */	public static <T> ModelTypeAdapterFactory getTypeAdapterFactory(Class<T> type) {		SerializationTypeAdapterFactory adapter = type == null ? null : type.getAnnotation(SerializationTypeAdapterFactory.class);		Class<?> adapterClass = adapter == null ? ModelTypeAdapterFactory.class : adapter.value();		ModelTypeAdapterFactory result = null;		try {			Constructor<?> constructor = adapterClass.getConstructor(new Class[] {					ConstructorConstructor.class, 					FieldNamingStrategy.class, 					Excluder.class });			result = (ModelTypeAdapterFactory) constructor.newInstance(new Object[] {					new ConstructorConstructor(Collections.<Type, InstanceCreator<?>>emptyMap()), 					FieldNamingPolicy.IDENTITY,					Excluder.DEFAULT.excludeFieldsWithoutExposeAnnotation() });		} catch (Exception ex) {			// creates a custom type factory for data models			result = new ModelTypeAdapterFactory(					new ConstructorConstructor(Collections.<Type, InstanceCreator<?>>emptyMap()),					FieldNamingPolicy.IDENTITY, 					Excluder.DEFAULT.excludeFieldsWithoutExposeAnnotation());		}		return result;	}	/**	 * Returns a Map of String containing, in order, each path component in the	 * string specified.	 * 	 * @param fieldPath	 *          A given field path	 * @return A Map of String containing, in order, each path component in the	 *         string specified	 */	private Map<String, Map<String, ?>> getFieldPathComponents(String fieldPath) {		List<String> fields = fieldPath == null ? null : Arrays.asList(fieldPath.split("/"));		return getFieldPathComponents(fields);	}	/**	 * Returns a Map of String containing, in order, each component in the List of	 * path components.	 * 	 * @param pathComponents	 *          A given list of path components	 * @return A Map of String containing, in order, each path component in the	 *         List specified	 */	private Map<String, Map<String, ?>> getFieldPathComponents(List<String> pathComponents) {		Map<String, Map<String, ?>> result = null;		if (pathComponents != null) {			result = new HashMap<String, Map<String, ?>>();			Map<String, Map<String, ?>> child = null;			if (pathComponents.size() > 1) {				child = getFieldPathComponents(pathComponents.subList(1, pathComponents.size()));			}						String fieldName = pathComponents.get(0);			Pattern p = Pattern.compile("(.+?)\\[(.*?)\\]");			Matcher m = p.matcher(fieldName);			// if the pattern: paramName[index] was found			if (m.find() && m.groupCount() == 2) {				fieldName = m.group(1);			}			result.put(fieldName, child);		}		return result;	}	/**	 * Query the foreign field objects from the underlying datastore.	 * 	 * @param path	 *          The field path	 * @throws SQLException	 *           Thrown if the given field path could not be expanded	 */	public void expand(String path) throws SQLException {		expand(getFieldPathComponents(path));	}	/**	 * Query the given foreign field objects from the underlying datastore.	 * 	 * @param fields	 *          A map of fields to be expanded	 * @throws SQLException	 *           Thrown if a given field could not be refreshed	 */	public void expand(Map<String, ?> fields) throws SQLException {		checkForDao();		expand(dao.getConnectionSource(), fields);	}		/**	 * Recursively refreshes the given foreign field or foreign collection	 * objects.	 * 	 * @param connectionSource	 *            the underlying connection to the data store	 * @param fields	 *            the fields to expand	 * @throws SQLException	 *             thrown if a given field could not be refreshed	 */	@SuppressWarnings({ "unchecked", "rawtypes" })	public void expand(ConnectionSource connectionSource, Map<String, ?> fields) throws SQLException {		// quick return if there was no field(s) to expand		if (fields == null) {			return;		}				ModelAttributes attributes = Schema.getAttributes(getClass());		Collection<String> fieldNames = attributes.getColumns().keySet();		for (String fieldName : fieldNames) {			Field field = attributes.getColumns().get(fieldName);			boolean isForeign = attributes.isForeignField(fieldName) || attributes.isForeignCollection(fieldName);			if (isForeign && fields.containsKey(fieldName)) {				field.setAccessible(true);				Object val = null;				try {					val = field.get(this);										if (val instanceof ForeignCollection) {						ForeignCollection<?> collection = (ForeignCollection) val;						collection.refreshCollection();												// Only eagar foreign collections retain reference to expanded foreign objects						if (collection.isEager()) {							CloseableIterator<?> itr = collection.closeableIterator();							try {								while (itr.hasNext()) {									Object element = itr.next();																		if (element instanceof Model) {										// Expands foreign objects										Model<?, ?> model = (Model<?, ?>) element;										Map<String, ?> fieldsToExpand = (Map<String, ?>) fields.get(fieldName);										model.expand(connectionSource, fieldsToExpand);									}								}							} finally {								try {									itr.close();				      	} catch (SQLException ex) {				      		// Ignored				      	}							}						}					} else if (val instanceof Model) {						// Refreshes data parameter of the data class with latest from the data store 						Dao dao = ((Model) val).getDao();						dao = dao == null ? DaoManager.createDao(connectionSource, val.getClass()) : dao; 						dao.refresh(val);												// Expands foreign objects						Model<?, ?> model = (Model<?, ?>) val;						Map<String, ?> fieldsToExpand = (Map<String, ?>) fields.get(fieldName);						model.expand(connectionSource, fieldsToExpand);					} else {						if (fields.get(fieldName) != null) {							// Cannot expand a field that is not a Model							throw new Exception();						}					}				} catch (Exception ex) {					// The model could not expand a given field					throw new SQLException(toString() + " could not expand field named " + fieldName, ex);				}			}		}	}		/**	 * Query for the object with the given ID and copies each field values from	 * the database to refresh the data parameter. Any local object changes to	 * persisted fields will be overwritten.	 * 	 * @param fields	 *          A map of foreign fields to be expanded	 * @throws SQLException	 *           Thrown if the object referenced could not be found or more than 1	 *           object in the datastore match the given criteria	 */	public int refresh(Map<String, ?> fields) throws SQLException {		checkForDao();		int result = refresh();		expand(getDao().getConnectionSource(), fields);		return result;	}		@Override	public int refresh() throws SQLException {		int result = super.refresh();		refreshed = result >= 1;		return result;	}		/**	 * Returns a boolean that indicates whether {@link #refresh()} or	 * {@link #refresh(Map)} has ever been called on this data model.	 * 	 * @return {@code true} if refresh was invoked, {@code false} otherwise	 */	public boolean refreshed() {		return refreshed;	}		/**	 * This method serializes this data model into its equivalent representation	 * as a tree of JsonElements.	 * 	 * @return JSON representation of this data model	 */	public JsonElement toJsonTree() {		// Uses a policy that disable serializing ID field only to serialize		// properties of this data model		return toJsonTree(ModelSerializationPolicy.DEFAULT.disableIdFieldOnlySerialization());	}		/**	 * This method serializes this data model into its equivalent representation	 * as a tree of JsonElements.	 * 	 * @param serializationStrategy	 *          The serialization strategy that describes how the data model	 *          should be serialized	 * @return JSON representation of this data model	 */	public JsonElement toJsonTree(ModelSerializationStrategy serializationStrategy) {		// Creates a custom type factory for data models		ModelTypeAdapterFactory modelTypeAdapterFactory = getTypeAdapterFactory(this.getClass());		modelTypeAdapterFactory.registerSerializationAdapter(getClass(), serializationStrategy);		// Creates a type factor for serializing foreign collections		ForeignCollectionTypeAdapterFactory foreignCollectionTypeAdapterFactory = new ForeignCollectionTypeAdapterFactory();		// Serialize the data model into a JSON representation 		Gson gson = new GsonBuilder()				.registerTypeAdapter(Date.class, new DateTypeAdapter())				.registerTypeAdapterFactory(modelTypeAdapterFactory)				.registerTypeAdapterFactory(foreignCollectionTypeAdapterFactory)				.serializeNulls()				.create();				return gson.toJsonTree(this);	}		/**	 * Converts the Model into its equivalent JSON representation.	 * 	 * @return JSON string representation of the Model	 */	public String toJson() {		// Uses a policy that disable serializing ID field only to allow serializing		// the current data model		return toJson(ModelSerializationPolicy.DEFAULT.disableIdFieldOnlySerialization());	}	/**	 * Converts the Model into its equivalent JSON representation.	 * 	 * @param serializationStrategy	 *          A list of properties whose value should be represented inline	 * @return JSON string representation of the model	 */	public String toJson(ModelSerializationStrategy serializationStrategy) {		// Creates a custom type factory for data models		ModelTypeAdapterFactory modelTypeAdapterFactory = getTypeAdapterFactory(this.getClass());		modelTypeAdapterFactory.registerSerializationAdapter(getClass(), serializationStrategy);		// Creates a type factory for serializing foreign collections		ForeignCollectionTypeAdapterFactory foreignCollectionTypeAdapterFactory = new ForeignCollectionTypeAdapterFactory();		// Serialize the data model into a JSON representation 		Gson gson = new GsonBuilder()				.registerTypeAdapter(Date.class, new DateTypeAdapter())				.registerTypeAdapterFactory(modelTypeAdapterFactory)				.registerTypeAdapterFactory(foreignCollectionTypeAdapterFactory)				.serializeNulls()				.create();		return gson.toJson(this);	}	/**	 * Deserializes the JSON into a data model.	 * 	 * @param <T>	 *          The class type of this data model	 * @param json	 *          the root of the parse tree of JsonElements from which the object	 *          is to be deserialized	 * @param creator	 *          An instance creator for creating {@link ForeignCollection} in the	 *          Model. If {@code creator} is {@code null},	 *          {@link ForeignCollection} cannot be deserialized	 * @param type	 *          the class of the data model	 * @return an initialized data object from the JSON	 * @throws JsonSyntaxException	 *           if json is not a valid representation for an object of type	 */	public static <T> T fromJson(			JsonElement json, 			ForeignCollectionInstanceCreator creator, 			Class<T> type) throws JsonSyntaxException {		if (json == null || !json.isJsonObject()) {			throw new JsonParseException("The Json was not a '" + type.getSimpleName() + "' object");		}		return fromJson(json.getAsJsonObject(), creator, type);	}	/**	 * Deserializes the JSON into a data model.	 * 	 * @param <T>	 * @param json	 *          the root of the parse tree of JsonElements from which the object	 *          is to be deserialized	 * @param creator	 *          An instance creator for creating {@link ForeignCollection} in the	 *          Model. If {@code creator} is {@code null},	 *          {@link ForeignCollection} cannot be deserialized	 * @param type	 *          the class of the data model	 * @return an initialized data object from the JSON	 * @throws JsonSyntaxException	 *           if json is not a valid representation for an object of type	 */	public static <T> T fromJson(			JsonObject json, 			ForeignCollectionInstanceCreator creator,			Class<T> type) throws JsonSyntaxException {		if (json == null) {			return null;		}		return fromJson(new JsonTreeReader(json), creator, type);	}	/**	 * Deserializes the JSON into a data model.	 * 	 * @param <T>	 * @param json	 *          the root of the parse tree of JsonElements from which the object	 *          is to be deserialized	 * @param creator	 *          An instance creator for creating {@link ForeignCollection} in the	 *          Model. If {@code creator} is {@code null},	 *          {@link ForeignCollection} cannot be deserialized	 * @param type	 *          the class of the data model	 * @return an initialized data object from the JSON	 * @throws JsonSyntaxException	 *           if json is not a valid representation for an object of type	 */	public static <T> T fromJson(			String json, 			ForeignCollectionInstanceCreator creator, 			Class<T> type) throws JsonSyntaxException {				if (json == null) {			return null;		}		StringReader reader = new StringReader(json);		return fromJson(reader, creator, type);	}	/**	 * Deserializes the JSON into a data model.	 * 	 * @param <T>	 * @param json	 *          the root of the parse tree of JsonElements from which the object	 *          is to be deserialized	 * @param creator	 *          An instance creator for creating {@link ForeignCollection} in the	 *          Model. If {@code creator} is {@code null},	 *          {@link ForeignCollection} cannot be deserialized	 * @param type	 *          the class of the data model	 * @return an initialized data object from the JSON	 * @throws JsonIOException	 *           if there was a problem writing to the Reader	 * @throws JsonSyntaxException	 *           if json is not a valid representation for an object of type	 */	public static <T> T fromJson(			Reader json, 			ForeignCollectionInstanceCreator creator, 			Class<T> type) throws JsonIOException, JsonSyntaxException {		JsonReader jsonReader = new JsonReader(json);		return fromJson(jsonReader, creator, type);	}	/**	 * Deserializes the JSON into a data model.	 * 	 * @param <T>	 * @param reader	 *          the json reader to read the json	 * @param creator	 *          An instance creator for creating {@link ForeignCollection} in the	 *          Model. If {@code creator} is {@code null},	 *          {@link ForeignCollection} cannot be deserialized	 * @param type	 *          the type of model object to deserialize into	 * @return an initialized data object from the json	 * @throws JsonIOException	 *           if there was a problem writing to the JsonReader	 * @throws JsonSyntaxException	 *           if json is not a valid representation for an object of type	 */	@SuppressWarnings("unchecked")	public static <T> T fromJson(			JsonReader reader, 			ForeignCollectionInstanceCreator creator, 			Class<T> type) throws JsonIOException, JsonSyntaxException {		if (reader == null) {			return null;		}		// Creates a custom type factory for data models		ModelTypeAdapterFactory modelTypeAdapterFactory = getTypeAdapterFactory(type);				// Creates the JSON builder		GsonBuilder gsonb = new GsonBuilder();		gsonb.registerTypeAdapter(Date.class, new DateTypeAdapter());		if (modelTypeAdapterFactory != null) {			gsonb.registerTypeAdapterFactory(modelTypeAdapterFactory);		}		gsonb.registerTypeAdapterFactory(new ForeignCollectionTypeAdapterFactory(creator));		Gson gson = gsonb.serializeNulls().create();		return (T) gson.fromJson(reader, type);	}	@Override	public boolean equals(Object other) {		if (other == null || other.getClass() != getClass()) {			return false;		}		boolean result = true;		ModelAttributes attributes = Schema.getAttributes(getClass());		Map<String, Field> columns = attributes.getColumns();		for (Field field : columns.values()) {			try {				field.setAccessible(true);				Object value = field.get(this);				Object otherValue = field.get(other);				if (value == null || otherValue == null) {					result = value == otherValue;				} else {					result = value.equals(otherValue);				}				if (!result) {					break;				}			} catch (Exception ex) {				// The field(s) were not comparable				result = false;				break;			}		}		return result;	}		/**	 * Indicates whether some other object is 'the same as' this one.	 * 	 * The other object is 'the same as' this one if both objects are of the same	 * type and identity attribute are the same	 * 	 * @param other the reference object to compare with	 * @return {@code true} if this object is the same as the referenced object, {@code false} otherwise	 */	public boolean sameAs(Object other) {		if (other == null || !other.getClass().equals(getClass())) {			return false;		}				boolean result = false;		ModelAttributes attributes = Schema.getAttributes(getClass());		String idField = attributes.getIdField();		try {			Field field = attributes.getColumns().get(idField);			field.setAccessible(true);			Object value = field.get(this);			Object otherValue = field.get(other);			if (value == null || otherValue == null) {				result = value == otherValue;			} else {				result = value.equals(otherValue);			}		} catch (Exception ex) {			// Ignore		}		return result;	}	/**	 * Determines whether or not the JSON object is "equal to" this Model.	 * 	 * @param json	 *          the reference object with which to compare	 * @return true if the JSON object is "equal" to this Model, false otherwise	 */	@SuppressWarnings("rawtypes")	public boolean equalsToJson(JsonElement json) {		if (json == null) {			return false;		}		String identityAttribute = "";		Object identity = null;		// Retrieves identity of the Model		if (Identity.class.isAssignableFrom(getClass())) {			identityAttribute = ((Identity) this).getIdentityAttribute();			identity = ((Identity) this).getIdentity();		} else {			ModelAttributes attributes = Schema.getAttributes(getClass());			String idField = attributes.getIdField();			if (idField != null) {				identityAttribute = idField;				identity = getFieldValue(identityAttribute);			}		}		// Identity of the model must be of primitive type		JsonPrimitive jsonIdentity = null;		if (json.isJsonObject()) {			JsonObject object = (JsonObject) json;			if (object.get(identityAttribute) == null || !object.get(identityAttribute).isJsonPrimitive()) {				return false;			} else {				jsonIdentity = object.get(identityAttribute).getAsJsonPrimitive();			}		} else if (json.isJsonNull() || json.isJsonArray()) {			return false;		} else {			jsonIdentity = json.getAsJsonPrimitive();		}		// Converts identity of the Model into a JsonPrimitive object		JsonPrimitive primitiveIdentity = null;		if (identity instanceof Character) {			primitiveIdentity = new JsonPrimitive(Character.class.cast(identity));		} else if (identity instanceof String) {			primitiveIdentity = new JsonPrimitive(String.class.cast(identity));		} else {			final Class<?>[] NUMBER_TYPES = { 					int.class, 					long.class, 					short.class, 					float.class,					double.class, 					byte.class, 					boolean.class, 					Integer.class, 					Long.class, 					Short.class,					Float.class, 					Double.class, 					Byte.class, 					Boolean.class };			Class<?> classOfPrimitive = identity.getClass();			for (Class<?> standardPrimitive : NUMBER_TYPES) {				if (standardPrimitive.isAssignableFrom(classOfPrimitive)) {					primitiveIdentity = new JsonPrimitive(Number.class.cast(identity));					break;				}			}		}		return jsonIdentity.equals(primitiveIdentity);	}		/**	 * Returns {@code true} if an object exists that matches this ID,	 * {@code false} otherwise.	 * 	 * @return {@code true} if an object exists in the underlying database that	 *         matches this ID, {@code false} otherwise	 */	public boolean exists() throws SQLException {		boolean result = false;				Dao<T, ID> dao = getDao();		if (dao != null) {			ID id = extractId();			result = id == null ? false : dao.idExists(id);		}				return result;	}	/**	 * Creates the data model if it does not already exist in the underlying	 * database. If the data model already exists, updates the underlying data	 * record.<br>	 * <br>	 * This method will create or update data objects as specified in the	 * {@link ModelSerializationStrategy}. That is, the level of object creation	 * or update is specified by the level of field expansion as specified in	 * {@code strategy}.<br>	 * <br>	 * This implementation will first serialize the data model into JSON based on	 * the serialization strategy and creates or updates the data models	 * serialized.	 * 	 * @param updateIfUnmodifiedSince	 *          update data objects only if it was not modified since the date	 *          specified	 * @param strategy	 *          the level of object creation or update as specified by the fields	 *          to expand	 * @param callback	 *          The callback to invoke after a data model is created or updated	 * @throws SQLException	 *           Thrown if there was an error	 */	public void createOrUpdate(			Date updateIfUnmodifiedSince, 			ModelSerializationStrategy strategy, 			Callback callback) throws SQLException {				Dao<T, ID> dao = getDao();		if (dao != null) {			// Call through to the {@link Dao.createOrUpdate} method			createOrUpdate(					dao.getConnectionSource(), 					updateIfUnmodifiedSince, 					toJsonTree(strategy).getAsJsonObject(), 					new ArrayList<Object>(), 					callback);		}	}		/**	 * Creates the data model if it does not already exist in the underlying	 * database. If the data model already exists, updates the underlying data	 * record.<br>	 * <br>	 * This method will create or update data objects as specified in the	 * {@link ModelSerializationStrategy}. That is, the level of object creation	 * or update is specified by the level of field expansion as specified in	 * {@code strategy}.<br>	 * <br>	 * This implementation will first serialize the data model into JSON based on	 * the serialization strategy and creates or updates the data models	 * serialized.	 * 	 * @param updateIfUnmodifiedSince	 *          update data objects only if it was not modified since the date	 *          specified	 * @param jsonObject	 *          the JSON object that specifies the field(s) that should be	 *          created/updated	 * @param callback	 *          The callback to invoke after a data model is created or updated	 * @throws SQLException	 *           Thrown if there was an error	 */	public void createOrUpdate(			Date updateIfUnmodifiedSince,			JsonObject jsonObject,			Callback callback) throws SQLException {				Dao<T, ID> dao = getDao();		if (dao != null) {			// Call through to the {@link Dao.createOrUpdate} method			createOrUpdate(					dao.getConnectionSource(), 					updateIfUnmodifiedSince, 					jsonObject, 					new ArrayList<Object>(), 					callback);		}	}	/**	 * Creates the data model if it does not already exist in the underlying	 * database. If the data model already exists, updates the underlying data	 * record	 * 	 * @param connectionSource	 *          the connection source to the underlying database	 * @param updateIfUnmodifiedSince	 *          update the data object only if it was not modified since the date	 *          specified	 * @param jsonObject	 *          the JSON object that specifies the field(s) that should be	 *          created/updated	 * @param stack	 *          a list of data models created or updated	 * @param callback	 *          the callback to execute after a model was created or updated	 * @return the number of records affected	 * @throws SQLException	 *           thrown if there was an error	 * @throws VersionConflictException	 *           thrown if the date that the data object was last modified is	 *           later than the Date specified in the updateIfUnmodifiedSince	 *           parameter	 */	@SuppressWarnings({ "unchecked", "rawtypes" })	private int createOrUpdate(			ConnectionSource connectionSource, 			Date updateIfUnmodifiedSince,			JsonObject jsonObject, 			List<Object> stack, 			Callback callback) throws SQLException, VersionConflictException {		setDao((Dao<T, ID>) DaoManager.createDao(connectionSource, getClass()));		Dao<T, ID> dao = getDao();		ID id = extractId();		Dao.CreateOrUpdateStatus currentObjectStatus = null;		int numberOfLinesChanged = 0;		boolean isIdExists = dao.idExists(id);		if (isIdExists) {			// The object already exists in the underlying data store			T object = dao.queryForId(id);			if (object instanceof Model && updateIfUnmodifiedSince != null) {				Object serverLastModDate = ((Model) object).getFieldValue(LAST_MODIFIED_DATE_FIELD_NAME);				if (serverLastModDate instanceof Date						&& ((Date) serverLastModDate).after(updateIfUnmodifiedSince)) {										throw new VersionConflictException(							"The resource requested has been modified after the time specified");				}			}		} else {			// The object does not exist in the database; updates created date			// to the current time			if (getFieldValue(CREATED_DATE_FIELD_NAME) == null) {				setFieldValue(CREATED_DATE_FIELD_NAME, Schema.getCurrentDate());			}		}		ModelAttributes attributes = Schema.getAttributes(getClass());		Collection<String> fieldNames = attributes.getColumns().keySet();		for (String fieldName : fieldNames) {			if (attributes.isForeignField(fieldName)) {				Object value = getFieldValue(fieldName);				JsonElement element = jsonObject == null ? null : jsonObject.get(fieldName);				// Creates/updates children foreign objects if they did not already				// exist				if (!stack.contains(value) && element != null && element.isJsonObject() && value != null) {					if (value instanceof Model) {						numberOfLinesChanged += ((Model) value).createOrUpdate(								connectionSource,								updateIfUnmodifiedSince, 								element.getAsJsonObject(), 								stack, 								callback);					} else {						// The data class was not a Model						Dao daoObject = DaoManager.createDao(connectionSource, value.getClass());						if (daoObject != null) {							daoObject.createIfNotExists(value);							stack.add(value);						}					}				}			}		}		if (!stack.contains(this)) {			// Updates the last modified date of the model			setFieldValue(LAST_MODIFIED_DATE_FIELD_NAME, Schema.getCurrentDate());			// Call through to the {@link Dao.createOrUpdate} method			if (callback != null) {				if (isIdExists) {					callback.beforeUpdate(this);				} else {					callback.beforeCreate(this);				}			}			currentObjectStatus = dao.createOrUpdate((T) this);			stack.add(this);			numberOfLinesChanged += currentObjectStatus.getNumLinesChanged();		}		String identityAttribute = "";		Object identity = null;		// Retrieves identity of the Model		if (Identity.class.isAssignableFrom(getClass())) {			identityAttribute = ((Identity) this).getIdentityAttribute();			identity = ((Identity) this).getIdentity();		} else {			String idField = attributes.getIdField();			if (idField != null) {				identityAttribute = idField;				identity = getFieldValue(identityAttribute);			}		}		for (String fieldName : fieldNames) {			if (attributes.isForeignCollection(fieldName)) {				Object value = getFieldValue(fieldName);				// Only a passive foreign collection needs to be created. Items added				// to lazy or eager foreign collection are added to the associated				// database table immediately				if (value instanceof PassiveForeignCollection) {					ArrayList<String> idList = new ArrayList<String>();					Class<?> dataType = null;					Dao daoObject = null;					Object[] data = ((PassiveForeignCollection) value).toArray();					JsonElement element = jsonObject == null ? null : jsonObject.get(fieldName);					JsonArray array = element != null && element.isJsonArray() ? element.getAsJsonArray() : null;					if (array != null && array.size() == data.length) {						for (int i = 0; i < data.length; i++) {							if (data[i] instanceof Model) {								Model model = (Model) data[i];								dataType = model.getClass();								daoObject = DaoManager.createDao(connectionSource, dataType);								// Create/update the Model if it was not already created/updated								if (!stack.contains(model) && array.get(i).isJsonObject()) {									numberOfLinesChanged += model.createOrUpdate(											connectionSource,											updateIfUnmodifiedSince, 											array.get(i).getAsJsonObject(), 											stack, 											callback);									if (numberOfLinesChanged > 0) {										Object idValue = model.extractId();										idList.add(idValue.toString());									}								} else if (array.get(i).isJsonPrimitive()) {									idList.add(array.get(i).getAsString());								}							} else {								// The data class was not a Model								dataType = data[i].getClass();								daoObject = DaoManager.createDao(connectionSource, dataType);								if (daoObject != null && !stack.contains(data[i]) && array.get(i).isJsonObject()) {									daoObject.createOrUpdate(data[i]);									stack.add(data[i]);									Object idValue = daoObject.extractId(data[i]);									idList.add(idValue.toString());								} else if (array.get(i).isJsonPrimitive()) {									idList.add(array.get(i).getAsString());								}							}						}						if (dataType != null && daoObject != null) {							ModelAttributes colDataClassAttr = Schema.getAttributes(dataType);							String foeignColumnName = attributes.getForeignCollectionForeignName(fieldName);							StatementBuilder<T, ?> statementBuilder = new QueryParser().parse(									new Query().fieldIsNotIn(colDataClassAttr.getIdField(), idList).fieldIsEqualTo(foeignColumnName, identity), 									daoObject.deleteBuilder(), 									dataType);														// Deletes entries in the database that do not exist in the passed-in JSON							daoObject.delete(((DeleteBuilder<T, ID>) statementBuilder).prepare());						}					}				}			}		}				// Execute the callback method		if (callback != null && currentObjectStatus != null) {			if (currentObjectStatus.isCreated()) {				callback.created(this);			} else if (currentObjectStatus.isUpdated()) {				callback.updated(this);			}		}		return numberOfLinesChanged;	}	/**	 * Creates the data item if it does not already exists in the underlying	 * database.	 * 	 * @param connectionSource	 *          The connection source to the database	 * @param stack	 *          a list of data objects created	 * @param callback	 *          the callback to execute after a model was created	 * @return the number of lines affected	 * @throws SQLException	 *           thrown if there was an exception	 */	@SuppressWarnings({ "unchecked", "rawtypes" })	private int createIfNotExists(			ConnectionSource connectionSource, 			List<Object> stack,			Callback callback) throws SQLException {		boolean created = false;		int numberOfLinesChanged = 0;		setDao((Dao<T, ID>) DaoManager.createDao(connectionSource, getClass()));		Dao<T, ID> dao = this.getDao();		ModelAttributes attributes = Schema.getAttributes(getClass());		Collection<String> fieldNames = attributes.getColumns().keySet();		for (String fieldName : fieldNames) {			if (attributes.isForeignField(fieldName)) {				// Creates children foreign objects first				Object value = getFieldValue(fieldName);				if (!stack.contains(value) && value != null) {					if (value instanceof Model) {						numberOfLinesChanged += ((Model) value).createIfNotExists(connectionSource, stack, callback);					} else {						// The data class was not a Model						Dao daoObject = DaoManager.createDao(connectionSource, value.getClass());						if (daoObject != null) {							daoObject.createIfNotExists(value);							stack.add(value);							numberOfLinesChanged++;						}					}				}			}		}		if (!stack.contains(this)) {			if (!dao.idExists(dao.extractId((T) this))) {				// Updates the created date and last modified date of the Model				if (getFieldValue(CREATED_DATE_FIELD_NAME) == null) {					setFieldValue(CREATED_DATE_FIELD_NAME, Schema.getCurrentDate());				}				setFieldValue(LAST_MODIFIED_DATE_FIELD_NAME, Schema.getCurrentDate());				// Call through to the {@link Dao.createIfNotExists} method				if (callback != null) {					callback.beforeCreate(this);				}				dao.createIfNotExists((T) this);								created = true;				numberOfLinesChanged++;			}						// Add the current object into the stack of objects created. This prevents			// circular creation			stack.add(this);		}		for (String fieldName : fieldNames) {			if (attributes.isForeignCollection(fieldName)) {				Object value = getFieldValue(fieldName);				// Only a passive foreign collection needs to be created. Items added				// to lazy or eager foreign collection are added to the associated				// database table immediately				if (value instanceof PassiveForeignCollection) {					Object[] data = ((PassiveForeignCollection) value).toArray();					for (int i = 0; i < data.length; i++) {						if (!stack.contains(data[i])) {							if (data[i] instanceof Model) {								numberOfLinesChanged += ((Model) data[i]).createIfNotExists(connectionSource, stack, callback);							} else {								// The data class was not a Model								Dao daoObject = DaoManager.createDao(connectionSource, data[i].getClass());								if (daoObject != null) {									daoObject.createIfNotExists(data[i]);									stack.add(data[i]);									numberOfLinesChanged++;								}							}						}					}				}			}		}				// Execute the callback method		if (callback != null && created) {			callback.created(this);		}		return numberOfLinesChanged;	}	/**	 * A call through to the {@link Dao#createIfNotExists()}.	 * 	 * @param connectionSource	 *          Connection to the underlying database	 * @return The number of rows updated in the database. This should be 1	 * @throws SQLException	 *           - thrown if there was an error	 */	public int createIfNotExists(ConnectionSource connectionSource) throws SQLException {		return createIfNotExists(connectionSource, new ArrayList<Object>(), null);	}	/**	 * A call through to the	 * {@code createIfNotExists(ConnectionSource, ArrayList, Callable)}.	 * 	 * @param connectionSource	 *          The connection source to the database	 * @param callback	 *          the callable to execute after the model was created (usually for	 *          logging)	 * @return The number of rows updated in the database	 * @throws SQLException	 *           thrown if there was an error	 */	public int createIfNotExists(ConnectionSource connectionSource, Callback callback) throws SQLException {		return createIfNotExists(connectionSource, new ArrayList<Object>(), callback);	}	/**	 * Call call through to the {@link BaseDaoEnabled#create()}.	 * 	 * @param connectionSource	 *          The connection source to the database	 * @return the number of rows updated in the underlying data store	 * @throws SQLException	 *           thrown if there was an error	 */	@SuppressWarnings("unchecked")	public int create(ConnectionSource connectionSource) throws SQLException {		// setup the database and DAO		Dao<T, ID> daoObject = null;		daoObject = (Dao<T, ID>) DaoManager.createDao(connectionSource, getClass());		setDao(daoObject);		// call through to the create() method in superclass		return create();	}	/**	 * Create a new row in the database from an object with updated created	 * date and last modified date.	 * 	 * @return The number of rows updated in the database. This should be 1.	 * @throws SQLException	 *           thrown if an error occurred	 */	@Override	public int create() throws SQLException {		// Updates the created date and last modified date of the Model		if (getFieldValue(CREATED_DATE_FIELD_NAME) == null) {			setFieldValue(CREATED_DATE_FIELD_NAME, Schema.getCurrentDate());		}		setFieldValue(LAST_MODIFIED_DATE_FIELD_NAME, Schema.getCurrentDate());		// call through to the create() method in superclass		return super.create();	}	/**	 * Create a new row in the database from an object preserving original created	 * date and last modified date.	 * 	 * @return The number of rows updated in the database. This should be 1.	 * @throws SQLException	 *           thrown if an error occurred	 */	public int write() throws SQLException {		return super.create();	}	/**	 * Deletes data objects identified by the query in the underlying data store.	 * 	 * @param <T> the java type of the data object to delete	 * @param <ID> the java type of the identity of the data object to delete	 * @param connectionSource	 *          the underlying data store connection	 * @param type	 *          the type of the data object	 * @param query	 *          the delete query	 * @return the number of rows affected by the query	 * @throws SQLException	 *           thrown if an error occurred	 */	@SuppressWarnings("unchecked")	public static <T, ID> int delete(			ConnectionSource connectionSource,			Class<T> type, 			Query query) throws SQLException {		// setup the database and DAOs		Dao<T, ID> daoObject = null;		daoObject = (Dao<T, ID>) DaoManager.createDao(connectionSource, type);		StatementBuilder<T, ?> statementBuilder = new QueryParser().parse(				query == null ? new Query() : query,				daoObject.deleteBuilder(), 				type);		return daoObject.delete(((DeleteBuilder<T, ID>) statementBuilder).prepare());	}		/**	 * Updates fields as detailed in {@code keyValues} for data objects	 * identified by the query in the underlying data store	 * 	 * @param connectionSource	 *            connection to the database	 * @param type	 *            the type of the data object	 * @param keyValues	 *            the key value pair of fields to be updated. The key is expected to be the 	 * @param query	 *            the update query	 * @param callback	 *            the listener to be invoked when the query was parsed	 * @return the number of rows affected by the query	 * @throws SQLException	 *             thrown if there was error updating the data records	 */	@SuppressWarnings("unchecked")	public static <T, ID> int udpate(			ConnectionSource connectionSource, 			Class<T> type, 			Map<String, Object> keyValues,			Query query, 			Callback callback) throws SQLException {				// Setup DAO if necessary		Dao<T, ID> dao = null;		dao = DaoManager.createDao(connectionSource, type);				QueryParser parser = new QueryParser();		UpdateBuilder<T, ID> updateBuilder = (UpdateBuilder<T, ID>) parser.parse(				query == null ? new Query() : query, 				dao.updateBuilder(),				type);				if (keyValues != null) {			ModelAttributes attrs = Schema.getAttributes(type);			for (String key : keyValues.keySet()) {				Object value = keyValues.get(key);				String columnName = attrs.getColumnName(key);				columnName = columnName == null || columnName.isEmpty() ? key : columnName;				updateBuilder.updateColumnValue(columnName, value);			}		}				return dao.update(((UpdateBuilder<T, ID>) updateBuilder).prepare());	}		@Override	public int update() throws SQLException {		setFieldValue(LAST_MODIFIED_DATE_FIELD_NAME, Schema.getCurrentDate());		// call through to the update() method in superclass		return super.update();	}	/**	 * Updates the data object with the values as specified in the JSON object.	 * 	 * @param json	 *          the json object containing the new values	 * @param creator	 *          An instance creator for creating {@link ForeignCollection} in the	 *          Model. If {@code creator} is {@code null},	 *          {@link ForeignCollection} cannot be deserialized	 * @return the number of rows updated.	 * @throws SQLException	 *           thrown if an error occurred	 */	@SuppressWarnings("unchecked")	public int update(JsonObject json, ForeignCollectionInstanceCreator creator) throws SQLException {		int result = 0;		// Quick return if there was nothing to update		if (json == null) {			return result;		}		T model = (T) Model.fromJson(json, creator, this.getClass());		if (model == null) {			return result;		}		boolean shouldUpdate = false;		ModelAttributes attributes = Schema.getAttributes(getClass());		Collection<String> fieldNames = attributes.getColumns().keySet();		for (String fieldName : fieldNames) {			Field field = attributes.getColumns().get(fieldName);						// Ignore ID columns, foreign collections, and read-only fields			if (json.has(fieldName) 					&& !attributes.isIdColumn(fieldName) 					&& !attributes.isForeignCollection(fieldName) 					&& !attributes.isReadOnly(fieldName)) {								field.setAccessible(true);				Object value = null;				try {					value = field.get(model);					field.set(this, value);					shouldUpdate = true;				} catch (Exception e) {					throw new SQLException(fieldName + " could not be updated to " + value, e);				}			}		}		// Only fires an update to the data store if one of the field(s) in		// the data model was changed		if (shouldUpdate) {			result = update();		}		return result;	}	/**	 * Retrieves the data object matching the given ID.	 * 	 * @param connectionSource	 *          The underlying datastore connection	 * @param type	 *          The type of the data object	 * @param id	 *          The ID of the data object	 * @return The data object with the given ID	 * @throws SQLException	 *           Thrown if an error occurred	 */	@SuppressWarnings("unchecked")	public static <T, ID> T find(			ConnectionSource connectionSource, 			Class<T> type, ID id) throws SQLException {				// Setup the database and DAOs		Dao<T, ID> daoObject = null;		daoObject = (Dao<T, ID>) DaoManager.createDao(connectionSource, type);		return daoObject == null ? null : daoObject.queryForId(id);	}	/**	 * Retrieves the data objects matching the given query.	 * 	 * @param connectionSource	 *          The underlying datastore connection	 * @param type	 *          The type of the data object	 * @param query	 *          the query	 * @return A list of data objects matching the given criteria	 * @throws SQLException	 *           Thrown if one of the query parameters is invalid	 */	@SuppressWarnings("unchecked")	public static <T, ID> List<T> find(			ConnectionSource connectionSource, 			Class<T> type, 			Query query) throws SQLException {		// Setup the database and DAOs		Dao<T, ID> daoObject = DaoManager.createDao(connectionSource, type);		if (daoObject == null) {			return null;		}				StatementBuilder<T, ?> statementBuilder = new QueryParser().parse(				query == null ? new Query() : query,				daoObject.queryBuilder(),				connectionSource,				type);				List<T> result = daoObject.query(((QueryBuilder<T, ID>) statementBuilder).prepare());		Iterator<?> itr = result.iterator();		while (itr.hasNext()) {			T model = (T) itr.next();			if (model instanceof Model) {				((Model<?, ?>) model).expand(query.getExpandingFields());			}		}				return result;	}		/**	 * Fetches the datastore matching the given {@code query}. This implementation	 * is different from {@link #find(ConnectionSource, Class, Query)} which	 * returns a {@link List}. This implementation is more efficient if the result	 * set is large.	 * 	 * @param connectionSource	 *          The underlying datastore connection	 * @param type	 *          The type of data object to return in the query	 * @param query	 *          The query to perform against the datastore	 * @return A {@link CloseableWrappedIterable}	 * @throws SQLException	 */	@SuppressWarnings("unchecked")	public static <T, ID> CloseableWrappedIterable<T> fetch(			ConnectionSource connectionSource, 			Class<T> type, 			Query query) throws SQLException {				// setup the database and DAOs		Dao<T, ID> dao = DaoManager.createDao(connectionSource, type);		if (dao == null) {			return null;		}				StatementBuilder<T, ?> statementBuilder = new QueryParser().parse(				query == null ? new Query() : query,				dao.queryBuilder(),				connectionSource,				type);				return dao.getWrappedIterable(((QueryBuilder<T, ID>) statementBuilder).prepare());	}	/**	 * Returns the number of entries in the resource identified by {@code type}.	 * The count is calculated after applying the {@code query} but ignoring limit	 * and offset options	 * 	 * @param <T>	 *          The Java type of the resource	 * @param <ID>	 *          The Java type of the ID of the data model	 * @param connectionSource	 *          The connection to the database	 * @param type	 *          The Java type of the data object	 * @param query	 *          The query to perform on the data collection	 * @return The number of entries in the entry collection or -1 if there was	 *         error	 * @throws SQLException	 *           Thrown if there was error	 */	public static <T> long countOf(ConnectionSource connectionSource, Class<T> type, Query query) throws SQLException {		// Setup the database and DAOs		Dao<T, ?> daoObject = DaoManager.createDao(connectionSource, type);		if (daoObject == null) {			return -1;		}				StatementBuilder<T, ?> statementBuilder = new QueryParser().parse(				query == null ? new Query() : query,				true,				daoObject.queryBuilder(),				connectionSource,				type);				QueryBuilder<T, ?> qb = (QueryBuilder<T, ?>) statementBuilder;		if (query != null && query.isResultDistinct()) {			long count = 0;			CloseableIterator<T> iterator = daoObject.iterator(qb.prepare());			try {				while (iterator.hasNext()) {					iterator.moveToNext();					count++;				}				return count;			} finally {				iterator.close();			}		} else {						qb.setCountOf(true);			return daoObject.countOf(qb.prepare());		}	}	@Override	public String toString() {		return toJson();	}		@Override	public int hashCode() {		ModelAttributes attributes = Schema.getAttributes(getClass());		String idField = attributes.getIdField();		Object value = getFieldValue(idField);		return value == null ? 0 : value.hashCode();	}	/**	 * Returns an array representation of the object.	 * 	 * @param excluder	 *          determines whether or not a given field should be excluded in the	 *          resulting array	 * @return an array of string contain the values of the fields	 */	public String[] toArray(Excluder excluder) {		ArrayList<String> result = new ArrayList<String>();		ModelAttributes attributes = Schema.getAttributes(getClass());		Collection<String> fieldNames = attributes.getColumns().keySet();		for (String fieldName : fieldNames) {			Field f = attributes.getColumns().get(fieldName);			if (!excluder.excludeClass(f.getType(), true) && !excluder.excludeField(f, true)					&& !attributes.isForeignCollection(f.getName())) {				try {					f.setAccessible(true);					Object value = f.get(this);					if (attributes.isForeignField(f.getName())) {						// Only serialize the identity of the foreign object						if (value instanceof Identity) {							Identity<?> id = (Identity<?>) value;							value = id.getIdentity();						} else {							value = null;						}					}					String str = value == null ? "null" : value.toString();					result.add(str);				} catch (Exception ex) {					// Adds an null string as the value for the inaccessible field					result.add("null");				}			}		}		String[] returnValue = new String[result.size()];		return result.toArray(returnValue);	}		/**	 * Checks whether or not the DAO of the model is valid.	 * 	 * @throws SQLException	 *             thrown if DAO of the model was not set	 */	protected void checkForDao() throws SQLException {		if (getDao() == null) {			throw new SQLException("Dao has not been set on " + getClass() + " object: " + this);		}	}}